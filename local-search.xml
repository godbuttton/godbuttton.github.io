<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue-Slot</title>
    <link href="/2024/02/21/Vue-Slot/"/>
    <url>/2024/02/21/Vue-Slot/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-Slot"><a href="#Vue-Slot" class="headerlink" title="Vue Slot"></a>Vue Slot</h1><ol><li><p>向子组件传入值可以用属性Props ，但是无法像组件传入模板。为了弥补某些场景下，向子组件传入模板，让子组件在它们的组件中渲染这些片段</p></li><li><p>无渲染组件</p></li></ol><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button class=&quot;fancy-btn&quot;&gt;<br>  &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;<br>&lt;/button&gt;<br><br>&lt;FancyButton&gt;<br>  Click me! &lt;!-- 插槽内容 --&gt;<br>&lt;/FancyButton&gt;<br></code></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote><p>插槽内容<strong>无法访问</strong>子组件的数据。Vue 模板中的表达式只能访问<strong>其定义时</strong>所处的作用域</p></blockquote><p>所以默认插槽内容上下文是当前父组件，因为模板内容是定义在父组件里面</p><h2 id="插槽类型"><a href="#插槽类型" class="headerlink" title="插槽类型"></a>插槽类型</h2><ol><li><p>默认插槽  ：<code>&lt;slot&gt;&lt;/slot&gt; </code>   实际会隐式等效于 name&#x3D;”default”</p></li><li><p>具名插槽： <code>&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</code>    具名插槽需要template包裹</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- header 插槽的内容放这里 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>   <br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">header</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 动态插槽名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">dynamicSlotName</span>]&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src=".././Vue-Slot/image-20240221091407194.png" alt="image-20240221091407194"></p></li></ol><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>由于渲染作用域问题，插槽内容<strong>无法访问</strong>子组件的数据。Vue 模板中的表达式只能访问<strong>其定义时</strong>所处的作用域</p><p>但是某些场景下需要混合渲染，父组件的某些数据结合子组件的某些数据渲染模板。所以需要子组件把数据提供给插槽</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- 默认插槽作用域 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:text</span>=<span class="hljs-string">&quot;greetingMessage&quot;</span> <span class="hljs-attr">:count</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>  &#123;&#123; slotProps.text &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--具名作用域插槽--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">header</span>=<span class="hljs-string">&quot;headerProps&quot;</span>&gt;</span><br>    &#123;&#123; headerProps &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;defaultProps&quot;</span>&gt;</span><br>    &#123;&#123; defaultProps &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>=<span class="hljs-string">&quot;footerProps&quot;</span>&gt;</span><br>    &#123;&#123; footerProps &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--同时具名作用域插槽和默认作用域插槽--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用显式的默认插槽 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;&#123; message &#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意点：</p><p>同时具名作用域插槽和默认作用域插槽，需要显示指名默认插槽 ，防止混淆。</p><h2 id="无渲染组件"><a href="#无渲染组件" class="headerlink" title="无渲染组件"></a>无渲染组件</h2><p>一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为<strong>无渲染组件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">MouseTracker</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;&#123; x, y &#125;&quot;</span>&gt;</span><br>  Mouse is at: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">MouseTracker</span>&gt;</span><br></code></pre></td></tr></table></figure><p>vue3  里面采用了组合式函数实现类似的效果 ，更加高级，并且还不会带来额外组件嵌套的开销</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程</title>
    <link href="/2023/08/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/08/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>入职了一家新公司，原本以为技术会很落后的，以为进去后也不过是画画页面 ，调用接口。结果进去第一天就发现技术都是最新的 ，业务需求都很简单，但是接手的代码都好新，看代码风格也都是满满的react风格。 vue3+tsx +函数式编程，每一项技术都需要重新学，头疼。</p><p>趁周末偷偷充下电，做做笔记，毕竟因为技术太菜被嫌弃就丢人丢大发了！ 也好，学习新的东西对自己的职业生涯也是大有帮助！</p><p>JavaScript 函数式编程是指使用函数来进行编程的一种范式，在函数式编程中，函数被视为一等公民，可以作为变量、参数和返回值来使用</p><ul><li>纯函数  相同的输入一定会产生相同的输出    常见的就是修改外部某个变量，影响了其他函数的执行</li><li>高阶函数   接受一个或多个函数为参数或者返回一个函数作为结果的函数</li><li>函数组合： 将多个函数按照一定的顺序和方式组合起</li><li>惰性计算： 只有在必要的时候才计算结果</li><li>不可变数据：  数据结构在被创建之后不能被修改，只能通过复制来创建新的数据结构</li></ul><h2 id="高阶函数："><a href="#高阶函数：" class="headerlink" title="高阶函数："></a>高阶函数：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">subtract</span> = (<span class="hljs-params">a, b</span>) =&gt; a - b;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">calculate</span> = (<span class="hljs-params">fn, a, b</span>) =&gt; <span class="hljs-title function_">fn</span>(a, b);<br><span class="hljs-title function_">calculate</span>(add, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <br><span class="hljs-title function_">calculate</span>(subtract, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>); <br></code></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>偏函数是一种将多个参数的函数转换为接受部分参数的新函数的技术。它基于现有函数创建一个新函数，该新函数在调用时只需要提供其定义中的一些参数，而不是所有必需的参数。一般通过bind方式处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-keyword">const</span> double = multiply.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">double</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure><h2 id="柯里化-Currying"><a href="#柯里化-Currying" class="headerlink" title="柯里化 Currying"></a>柯里化 Currying</h2><p>柯里化是一种将接受多个参数的函数转换为一系列只接受单个参数的函数的技术。这使我们更容易创建可组合、通用和模块化的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> addOne = <span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addOne</span>(<span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><p>将一个包含多个参数的函数转换成另一个函数，这个函数如果被给到的参数少于正确的数量，就会返回一个接受剩余参数的函数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">add</span> = (x, y) =&gt; x + y<br><br><span class="hljs-keyword">const</span> curriedAdd = _.curry(<span class="hljs-keyword">add</span>)<br></code></pre></td></tr></table></figure><h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>函数组合是指将两个或多个函数结合在一起以产生一个新函数的技术，管道运算符（Pipeline Operator）和compose函数。</p><p>pip 运算符 ES2021</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-number">3</span> |&gt; <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>) |&gt; square;<br></code></pre></td></tr></table></figure><p>compose函数,compose函数是一个接受两个或多个函数作为参数并返回一个新函数的高阶函数,  该新函数将把传入的值作为最右边的函数的输入，并将结果带回到最左边的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> add =&gt; <span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> a+b<br><span class="hljs-keyword">const</span> sqr=&gt;<span class="hljs-function"><span class="hljs-params">a</span>=&gt;</span>a*a<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">compose</span>=(<span class="hljs-params">...fn</span>)=&gt;<span class="hljs-function">(<span class="hljs-params">arg</span>)=&gt;</span>fn.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>)=&gt;</span><span class="hljs-title function_">cur</span>(acc),arg);<br><span class="hljs-keyword">const</span> result =  <span class="hljs-title function_">compose</span>(sqr,add.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>))(<span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)  <span class="hljs-comment">//输出11  3*3+2</span><br><br></code></pre></td></tr></table></figure><h2 id="纯函数-Purity"><a href="#纯函数-Purity" class="headerlink" title="纯函数 Purity"></a>纯函数 Purity</h2><ul><li>可缓存性：由于纯函数的输出只取决于其输入，所以我们可以将它们的执行结果缓存起来</li><li>可测试性：因为纯函数不依赖于外部状态，所以它们更容易被测试和调试，也更容易推理。</li><li>并行代码：由于纯函数没有任何共享状态，所以它们更容易在并行环境中工作。</li></ul><h2 id="副作用-（Side-Effects）"><a href="#副作用-（Side-Effects）" class="headerlink" title="副作用 （Side Effects）"></a>副作用 （Side Effects）</h2><p>目标是尽可能地使用纯函数，但是在某些情况下，副作用是无法避免的</p><ul><li>I&#x2F;O 操作：读写文件、网络请求</li><li>状态管理：有时候我们需要在函数执行过程中记录一些状态信息</li><li>DOM 操作：JavaScript通常用于HTML文档的交互</li></ul><h2 id="幂等（Idempotent）"><a href="#幂等（Idempotent）" class="headerlink" title="幂等（Idempotent）"></a>幂等（Idempotent）</h2><p>幂等（Idempotent）是指对于同一输入值，函数的输出结果总是相同的.无论调用函数多少次，返回的结果都是一样的</p><ul><li>操作数据库，执行多次也只是插入一次</li><li>缓存数据</li><li>网络重新试，调用多次，仅仅只执行一次</li></ul><h2 id="Point-Free"><a href="#Point-Free" class="headerlink" title="Point-Free"></a>Point-Free</h2><p>它的核心思想是将函数组合起来，并通过函数组合实现业务逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 命令式编程(Imperative programming)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">return</span> n * n;<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">square</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 9</span><br><br><span class="hljs-comment">// Point-Free 风格(Point-Free style)</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">square</span> = n =&gt; n * n;<br><br><span class="hljs-keyword">const</span> result = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">reduce</span>(add, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> squareResult = <span class="hljs-title function_">square</span>(result);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(squareResult); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><h2 id="契约-Contracts"><a href="#契约-Contracts" class="headerlink" title="契约 (Contracts)"></a>契约 (Contracts)</h2><p>在函数式编程中，契约（Contracts）是指一种基于先决条件和后置条件的编程范式，它描述了一个函数或模块的行为和输入输出之间的关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sendMessage = <span class="hljs-title function_">contract</span>(<span class="hljs-function">(<span class="hljs-params">message, callback</span>) =&gt;</span> &#123;<br>  contract.<span class="hljs-title function_">assert</span>(<br>    contract.<span class="hljs-title function_">typeOf</span>(<span class="hljs-string">&quot;string&quot;</span>, message),<br>    <span class="hljs-string">&#x27;sendMessage(message, callback): message should be a string&#x27;</span><br>  );<br>  contract.<span class="hljs-title function_">assert</span>(<br>    contract.<span class="hljs-title function_">typeOf</span>(<span class="hljs-string">&quot;function&quot;</span>, callback),<br>    <span class="hljs-string">&#x27;sendMessage(message, callback): callback should be a function&#x27;</span><br>  );<br><br>  <span class="hljs-comment">// 实际发送逻辑</span><br>  <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Message sent successfully!&quot;</span>);<br>&#125;);<br><br><span class="hljs-title function_">sendMessage</span>(<span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="范畴-Category"><a href="#范畴-Category" class="headerlink" title="范畴 (Category)"></a>范畴 (Category)</h2><p>在 JavaScript 函数式编程中，我们可以将范畴看作是由一些函数和数据类型组成的集合，并通过这些函数和数据类型之间的关系来描述和处理问题。</p><ul><li><p>函数构成范畴</p></li><li><p>Functor 范畴  函子</p></li><li><p>Monad 范畴 <code>Promise</code> 和 <code>IO</code> 都是 Monad 的例子。Monad 主要用于异步操作、异常处理等场景</p></li></ul><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>在 JavaScript 函数式编程中，值（Value）是指一种数据结构，它主要用于表示状态不可变的数据。值类型包括基本类型（如 <code>number、string、boolean</code>）以及复合类型（如数组、对象等），值类型的特点是不可变性，即在创建之后它们的值不能被修改。有利于编写纯函数 </p><p><code>immutable.js</code> 库就提供了一系列的数据类型（如 List、Map、Set 等），这些数据类型都是不可变的，只能通过创建新的对象来修改它们的状态。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>在 JavaScript 中，我们通常使用 Object.freeze() 方法将一个对象转换为常量对象，使得该对象的值不能被修改。定义常量对象的示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">COLORS</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(&#123;<br>  <span class="hljs-attr">RED</span>: <span class="hljs-string">&#x27;#ff0000&#x27;</span>,<br>  <span class="hljs-attr">GREEN</span>: <span class="hljs-string">&#x27;#00ff00&#x27;</span>,<br>  <span class="hljs-attr">BLUE</span>: <span class="hljs-string">&#x27;#0000ff&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="函子-Functor"><a href="#函子-Functor" class="headerlink" title="函子 (Functor)"></a>函子 (Functor)</h2><p>函子（Functor）是一种特殊的对象类型，它可以看作是一个容器，用于封装一些值，并提供一些方法来操作这些值。函子实际上是一种抽象的概念，它并不限定具体的实现方式，在实际应用中可以使用数组、对象等数据结构来实现。处理不纯的函数副作用</p><h2 id="抬升-Lift"><a href="#抬升-Lift" class="headerlink" title="抬升 (Lift)"></a>抬升 (Lift)</h2><p> JavaScript 函数式编程中，抬升（Lift）是一种将普通函数转换为可用于处理函子对象的高阶函数的技术。通过使用抬升，我们可以将多个函数组合起来，形成一个新的函数，用于操作函子对象。</p><p>具体实现方式是，我们首先定义一个抬升函数 <code>lift()</code>，该函数接受一个或多个普通函数作为参数，并返回一个新的函数，该新函数可以接受一个或多个函子对象，并将这些函子对象传递给原有函数进行处理，最终返回包含处理结果的新的函子对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义函子对象 Maybe</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Maybe</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果有值就执行传入的处理函数</span><br>  <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Maybe</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Maybe</span>(<span class="hljs-literal">null</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 抬升函数 lift()</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lift</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> first = args[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Maybe</span>) &#123;<br>      <span class="hljs-comment">// 如果是 Maybe 对象，则调用 map() 方法处理</span><br>      <span class="hljs-keyword">return</span> first.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-comment">// 调用原始函数处理</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(...[value, ...args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)]);<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 否则直接调用函数</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(...args);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 定义两个普通函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">a, b</span>) =&gt; a * b;<br><br><span class="hljs-comment">// 使用抬升处理两个函子对象</span><br><span class="hljs-keyword">const</span> liftedAdd = <span class="hljs-title function_">lift</span>(add);<br><span class="hljs-keyword">const</span> liftedMultiply = <span class="hljs-title function_">lift</span>(multiply);<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">liftedAdd</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Maybe</span>(<span class="hljs-number">5</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Maybe</span>(<span class="hljs-number">4</span>)).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">res1</span>) =&gt;</span><br>  <span class="hljs-title function_">liftedMultiply</span>(res1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Maybe</span>(<span class="hljs-number">10</span>))<br>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出： &quot;90&quot;</span><br></code></pre></td></tr></table></figure><h2 id="引用透明性-Referential-Transparency"><a href="#引用透明性-Referential-Transparency" class="headerlink" title="引用透明性 (Referential Transparency)"></a>引用透明性 (Referential Transparency)</h2><p>在 JavaScript 函数式编程中，<code>引用透明性（Referential Transparency）</code>是指一个函数的输出只与它的输入有关，而不依赖于其他外部状态或变量。。</p><p>不依赖外部环糊</p><h2 id="等式推理-Equational-Reasoning"><a href="#等式推理-Equational-Reasoning" class="headerlink" title="等式推理 (Equational Reasoning)"></a>等式推理 (Equational Reasoning)</h2><p>在 JavaScript 函数式编程中，等式推理（Equational Reasoning）是指使用等式来推导代码的正确性。也就是说，我们可以通过等式关系来证明某个函数的正确性，而不需要运行它。这个过程主要依赖于引用透明性，即一个函数的输出只由输入决定，不受外部状态影响。</p><p>等式推理可以帮助我们更好地理解一段代码的含义和作用，并且能够快速地发现可能存在的错误。在函数式编程中，我们把每个函数看做是数学上的一个函数，也就是说，它们只接受输入参数并返回输出结果，不存在副作用，因此可以进行等式推导。</p><p>实际就是方便测试 也没啥意义</p><h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><p>阅读一些典型的代码块</p><ol><li><p>export  const tap &#x3D; (fn) &#x3D;&gt; async (data) &#x3D;&gt; {</p><p> await fn(data);</p><p> return data;</p></li></ol><p>   };</p><p>   只是异步做一些事情，不影响主流程，输入是多少 输出是多少。 通常用于更新视图，操作dom本身也是释放副作用</p><ol start="2"><li>export const namespace &#x3D; (name:any) &#x3D;&gt; (payload:any) &#x3D;&gt; async ( stream ) &#x3D;&gt; ({ …stream, [name]: typeof payload &#x3D;&#x3D;&#x3D; “function” ? await payload(stream[name], stream) : payload });</li></ol><p>   不清楚</p><p>   namespace(‘prop’)  （payload）   stream  &#x3D;&#x3D;》 {</p><p>   …stream  ,</p><p>   prop: payload(stream [prop], payload ) | payload</p><p>   }</p><p>3. </p><ol start="4"><li><p>export const spaceslide &#x3D; (from, to) &#x3D;&gt; (fn) &#x3D;&gt; namespace(to)(async (_, stream) &#x3D;&gt; await fn(stream[from]));</p><p>​</p></li><li></li><li></li><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript</title>
    <link href="/2023/07/07/typescript/"/>
    <url>/2023/07/07/typescript/</url>
    
    <content type="html"><![CDATA[<h2 id="Typescript-基础"><a href="#Typescript-基础" class="headerlink" title="Typescript 基础"></a>Typescript 基础</h2><p>js是个弱类型语言，动态语言即，变量的类型是不确定的。弱类型灵活，但是强类型更有利，可以降低系统的复杂度，在编译时检查类型错误。</p><p>ts属于 JavaScript 的超集，可以编译为 JavaScript 执行。 它的最大特点就是支持强类型和ES6 class</p><p>文档：<a href="https://www.tslang.cn/docs/handbook/basic-types.html">https://www.tslang.cn/docs/handbook/basic-types.html</a></p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p> npm install -g typescript</p><p>tsc -w  watch文件</p><p>tsc xx.ts  编译ts文件</p><p>tsc  –init 初始化配置 tsconfig.json</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义基础类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: boolean = <span class="hljs-literal">false</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">num1</span>:number =<span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">num2</span>:number = <span class="hljs-number">0x12</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">name1</span>: string = <span class="hljs-string">&quot;zhangsan&quot;</span><br><span class="hljs-comment">//数组定义方式</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>:any[]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br><span class="hljs-keyword">let</span> <span class="hljs-attr">list2</span>:<span class="hljs-title class_">Array</span>&lt;number&gt;=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>list2.<span class="hljs-title function_">push</span>(<span class="hljs-number">34</span>)<br><br><span class="hljs-comment">//元组类型允许表示一个已知元素数量和类型的数组</span><br><span class="hljs-keyword">let</span>  <span class="hljs-attr">xtuple</span>: [string, number];<br>xtuple=[<span class="hljs-string">&quot;dw&quot;</span>,<span class="hljs-number">33</span>]<br><br><span class="hljs-comment">// 枚举类型,实际转化为了 </span><br><span class="hljs-comment">// </span><br>enum <span class="hljs-title class_">Color</span>&#123;<br>    <span class="hljs-title class_">Red</span>,<br>    <span class="hljs-title class_">Green</span>,<br>    <span class="hljs-title class_">Blue</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">colorValue</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">colorName</span>:<span class="hljs-title class_">String</span> = <span class="hljs-title class_">Color</span>[<span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">typeAny</span>:any  = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">typeObject</span>:object  = &#123;&#125;;<br><br><span class="hljs-comment">// void类型  严格模式只有undefine 非严格模式undefine、null</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">voidVal</span>: <span class="hljs-keyword">void</span> ;<br><br>voidVal=<span class="hljs-literal">null</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>):<span class="hljs-keyword">void</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">let</span> fun1=():<span class="hljs-function"><span class="hljs-params">void</span>=&gt;</span> <span class="hljs-keyword">void</span><br><br><br><span class="hljs-comment">//never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">message: string</span>): never &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br><br><span class="hljs-keyword">let</span> error1=():<span class="hljs-function"><span class="hljs-params">never</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;ddd&#x27;</span>);<br>&#125; <br><br><span class="hljs-comment">// 类型断言 </span><br><span class="hljs-comment">//“尖括号”语</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: any = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength1</span>: number = (&lt;string&gt;someValue).<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// as语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength2</span>: number = (someValue <span class="hljs-keyword">as</span> string).<span class="hljs-property">length</span>;<br><br><br></code></pre></td></tr></table></figure><p>元组的实际形式</p><p><img src="/typescript/image-20230711143245236.png"></p><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把 <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p><p><img src="../typescript/image-20230711150447259.png" alt="image-20230711150447259"></p><h2 id="函数、接口、对象"><a href="#函数、接口、对象" class="headerlink" title="函数、接口、对象"></a>函数、接口、对象</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SquareConfig</span> &#123;<br>    color?: <span class="hljs-built_in">string</span>;<br>    width?: <span class="hljs-built_in">number</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createSquare</span>(<span class="hljs-params">config:SquareConfig</span>):&#123;<span class="hljs-attr">color</span>:<span class="hljs-built_in">string</span>;<span class="hljs-attr">area</span>:<span class="hljs-built_in">number</span>&#125; &#123;<br>    <span class="hljs-keyword">let</span> newSquare = &#123;<br>        <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;white&quot;</span>,<br>        <span class="hljs-attr">area</span>:<span class="hljs-number">100</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(config.<span class="hljs-property">color</span>) &#123;<br>        newSquare.<span class="hljs-property">color</span>=config.<span class="hljs-property">color</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(config.<span class="hljs-property">width</span>) &#123;<br>        newSquare.<span class="hljs-property">area</span> =  config.<span class="hljs-property">width</span>*config.<span class="hljs-property">width</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>  newSquare<br>  &#125; <br><br>  <span class="hljs-keyword">let</span> mySquare = <span class="hljs-title function_">createSquare</span>(&#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&quot;black&quot;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySquare)<br><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>; <span class="hljs-comment">// 数组的使用ReadonlyArray&lt;number&gt; </span><br>  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>:<span class="hljs-title class_">Point</span> = &#123;<br>  <span class="hljs-attr">x</span>:<span class="hljs-number">122</span>,<br>  <span class="hljs-attr">y</span>:<span class="hljs-number">33</span><br>&#125;<br>a.<span class="hljs-property">x</span>=<span class="hljs-number">2</span> <span class="hljs-comment">///报错</span><br><br><br>(a <span class="hljs-keyword">as</span> &#123;&#125;).<span class="hljs-property">x</span>=<span class="hljs-number">3</span>  <span class="hljs-comment">// 可以断言绕过去  乱用</span><br><span class="hljs-comment">// 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。</span><br><br><br><br><br></code></pre></td></tr></table></figure><p>接口 ： 接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p><p>可索引的类型：</p><p>可以同时使用两种类型的索引，但是<strong>数字索引的返回值</strong>必须是<strong>字符串索引返回值</strong>类型的<strong>子类型</strong>。 这是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-attr">breed</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NotOkay</span> &#123;<br>  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Dog</span>;<br>  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-title class_">Animal</span>; <span class="hljs-comment">// Error</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Okay</span> &#123;<br>  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Animal</span>;<br>  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类实现接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<br>    <span class="hljs-title function_">setTime</span>(<span class="hljs-attr">d</span>: <span class="hljs-title class_">Date</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<br>    <span class="hljs-title function_">setTime</span>(<span class="hljs-params">d: <span class="hljs-built_in">Date</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTime</span> = d;<br>    &#125;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>) &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口继承接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-attr">sideLength</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> square = &lt;<span class="hljs-title class_">Square</span>&gt;&#123;&#125;;<br><br></code></pre></td></tr></table></figure><p>混合类型：一个对象可以同时做为函数和对象使用，并带有额外的属性。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>由于类名作为类型使用，实际上代表一个对象，因此可以把类看作为对象类型起名。事实上，TypeScript 有三种方法可以为对象类型起名：type、interface 和 class。</p><p>class表示的实例类型 ，如果要获取自身类型，typeof 语法，或者类本身是一种构造函数，所以可以用构造函数写法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPoint</span>(<span class="hljs-params"></span><br><span class="hljs-params">  PointClass: <span class="hljs-keyword">new</span> (x:<span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span>) =&gt; Point,</span><br><span class="hljs-params">  x: <span class="hljs-built_in">number</span>,</span><br><span class="hljs-params">  y: <span class="hljs-built_in">number</span></span><br><span class="hljs-params"></span>):<span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PointClass</span>(x, y);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>有些时候，函数返回值的类型与参数类型是相关的。 泛型的特点就是带有“类型参数”（type parameter）</p><p>函数调用的时候一般要具体指定类型，也可以让ts推断。复杂场景还是需要指定</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> comb&lt;T&gt;(<span class="hljs-attr">arr1</span>:T[], <span class="hljs-attr">arr2</span>:T[]):T[] &#123;<br>  <span class="hljs-keyword">return</span> arr1.<span class="hljs-title function_">concat</span>(arr2);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>函数泛型(<code>function</code>关键字定义的泛型函数，类型参数放在尖括号中，写在函数名后面。)</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> id&lt;T&gt;(<span class="hljs-attr">arg</span>:T):T &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>变量定义的函数</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">let</span> <span class="hljs-attr">myId</span>:&lt;T&gt;<span class="hljs-function">(<span class="hljs-params">arg:T</span>) =&gt;</span> T = id;<br></code></pre></td></tr></table></figure></li><li><p>接口的泛型写法</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-title class_">Type</span>&gt; &#123;<br>  <span class="hljs-attr">contents</span>: <span class="hljs-title class_">Type</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">box</span>:<span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br></code></pre></td></tr></table></figure> <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>  <span class="hljs-title function_">compareTo</span>(<span class="hljs-attr">value</span>:T): <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-title class_">Rectangle</span>&gt; &#123;<br><br>  <span class="hljs-title function_">compareTo</span>(<span class="hljs-attr">value</span>:<span class="hljs-title class_">Rectangle</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 接口定义方法里面</span><br>nterface <span class="hljs-title class_">Fn</span> &#123;<br>  &lt;<span class="hljs-title class_">Type</span>&gt;(<span class="hljs-attr">arg</span>:<span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> id&lt;<span class="hljs-title class_">Type</span>&gt;(<span class="hljs-attr">arg</span>:<span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span> &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">myId</span>:<span class="hljs-title class_">Fn</span> = id;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Vue3</title>
    <link href="/2023/06/29/%E5%88%9D%E8%AF%86Vue3/"/>
    <url>/2023/06/29/%E5%88%9D%E8%AF%86Vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><p>最近失业了，看网上招聘信息，对比自己的经历，四个短板，Vue3、React、TS、Webgis（估计与智慧城市有关，更多的webgis的招聘多起来了）</p><p>Vue3 ：<a href="https://cn.vuejs.org/guide/introduction.html#api-styles">https://cn.vuejs.org/guide/introduction.html#api-styles</a></p><p>组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。函数式编程</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">选项式API  就会通过不同选项和生命周期钩子函数割裂了代码逻辑，导致了代码复用的困难，并且去看逻辑的时候，通常要找到对应的生命周期里面函数方法，再去阅读代码<br></code></pre></td></tr></table></figure><p><em><strong>1.重写数据绑定2. vdom性能优化 3.framents的支持 4.tree-shaking  5.Composition API</strong></em></p><p>问题1: setup2种方式 以及区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 方式1</span><br>&lt;script&gt;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment">// 返回值会暴露给模板和其他的选项式 API 钩子</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      count<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) <span class="hljs-comment">// 0</span><br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;count++&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="hljs-comment">//方式2</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="language-xml">      </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>2.特性</p><ul><li><p>动态绑定多个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">objectOfAttrs</span>: &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;container&#x27;</span>,<br>      <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;wrapper&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br>&lt;div v-bind=<span class="hljs-string">&quot;objectOfAttrs&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure></li><li><p>动态参数语法限制,我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写,另外避免空格和引号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 这会触发一个编译器警告 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[&#x27;<span class="hljs-attr">foo</span>&#x27; + <span class="hljs-attr">bar</span>]=<span class="hljs-string">&quot;value&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">someAttr</span>]=<span class="hljs-string">&quot;value&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li><li><p>响应式代理</p><p>vue2 在组件实例化的时候执行data方法，返回的响应式对象挂载在this上</p><p>vue3 则基于Proxy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">someObject</span>: &#123;&#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> newObject = &#123;&#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">someObject</span> = newObject<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObject === <span class="hljs-variable language_">this</span>.<span class="hljs-property">someObject</span>) <span class="hljs-comment">// false</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>生命周期图</p><p><img src="../初识Vue3/lifecycle.16e4c08e.png" alt="组件生命周期图示"></p></li><li><p>响应式声明</p><p>reactive() :    对象类型        ref ()： 对象类型和基础类型都可以      </p><p>修改的时候refVal.value</p><p>ref声明的需要用.value</p></li><li><p>watch 可以监听ref 也可以监听的是一个ref 或者一个computed 或者是一个getter函数 或者是一个reactive对象 或者多个数据源组成的数组</p><p>也一样有深度监听 {}  flush dom监听以后在触发 回调里面需要操作dom时候用到</p></li><li><p>watchEffect  自动收集依赖，会立刻运行一次，默认也是dom更新之前执行，如果要在dom运行之后执行 ，flush：post</p><p>初始化如果需要依赖dom更新后的数据，写在onmounted里面</p><p>返回值是停止监听的函数</p><p>watchEffect有点像computed:</p><ul><li>但是computed更注重的是计算出来的值（回调函数的返回值），所以必须要写返回值</li><li>而watch更注重的是过程（回调函数的函数体），所以不用写返回值</li></ul></li><li><p>app.component 注册</p><p>setup里面自动注册</p></li><li><p>emits 事件 对象形式 可以校验，但是不管校验通过不通过都会执行</p></li><li><p>provide 和inject  如果需要子组件改变父的 provide里面传递方法 注入到子组件就可以了</p></li><li><p>useRoute 用于获取到route对象</p></li><li><p>选项式组件 数据默认对外部是可见的，如果声明了expose选项 ，则只能访问expose暴露出去的属性和方法 </p><p>组合式API  <code>&lt;script setup&gt;</code> 默认是私有的,父无法访问，除非用defineExpose宏显示暴露出去的</p><h2 id="vue-的几点思考"><a href="#vue-的几点思考" class="headerlink" title="vue 的几点思考"></a>vue 的几点思考</h2><p>HTML 标签和属性名称是不分大小写的，所以浏览器会把任何大写的字符解释为小写</p><p>定义组件的几种写法，模板 以及js     jsx defineComponent   export default  vue </p><p>用到函数的地方</p><script setup>不需要导入 的宏编译命令`defineProps` 是一个仅 `<script setup>` 中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板。`defineProps` 会返回一个对象，其中包含了可以传递给组件的所有 props：defineEmits命名：props 优先驼峰   组件名 PascalCase   模板里面属性传参kebab-case   接收驼峰触发事件 ​$emit("someEvent")  @some-event</li></ul><p>我们在 <code>&lt;template&gt;</code> 中使用的 <code>$emit</code> 方法不能在组件的 <code>&lt;script setup&gt;</code> 部分中使用，但 <code>defineEmits()</code> 会返回一个相同作用的函数供我们使用：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;inFocus&#x27;</span>, <span class="hljs-string">&#x27;submit&#x27;</span>],<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, ctx</span>) &#123;<br>    ctx.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;submit&#x27;</span>)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>  验证</p><p>  透传</p><p>  const attrs &#x3D; useAttrs() </p><p>  defineOptions({  inheritAttrs: false })  透传 v-bind&#x3D;”$attrs”</p><p>  插槽 插槽#号  实际就是v-slot 对应的就是子组件slotname</p><p>  子slot像父传送数据 时候</p><p>  v-slot&#x3D;”slotProps”  默认的</p><p>  v-slot:name&#x3D;”slotProps”  终极形式</p><p>  #name&#x3D;”slotProps”</p><p>  子孙传递</p><p>  provide(‘key’, count)</p><p>  应用层面</p>  <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">app.<span class="hljs-keyword">provide</span>(<span class="hljs-comment">/* 注入名 */</span> <span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-comment">/* 值 */</span> <span class="hljs-string">&#x27;hello!&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="状态管理Pinia"><a href="#状态管理Pinia" class="headerlink" title="状态管理Pinia"></a>状态管理Pinia</h2><p>  更好的支持 TypeScript    更好支持Composition API   核心概念 getter  state actions   </p><p>  代码片段</p><p>  <img src="../初识Vue3/image-20230706173531516.png" alt="image-20230706173531516"></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 也可以定义为</span><br>  <span class="hljs-comment">// state: () =&gt; (&#123; count: 0 &#125;)</span><br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>    &#125;,<br>  &#125;,<br>&#125;)<br><br><span class="hljs-keyword">import</span> &#123; useCounterStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/counter&#x27;</span><br><br> <span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> useCounterStore.<span class="hljs-property">count</span>),<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-基础</title>
    <link href="/2023/05/30/Spring-%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/05/30/Spring-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>官方文档地址 :<a href="https://docs.spring.io/spring-framework/reference/core/beans/introduction.html">https://docs.spring.io/spring-framework/reference/core/beans/introduction.html</a></p><p>B站评论区中文：<a href="https://www.docs4dev.com/docs/zh/spring-framework/4.3.21.RELEASE/reference/beans.html#beans-factory-scopes">https://www.docs4dev.com/docs/zh/spring-framework/4.3.21.RELEASE/reference/beans.html#beans-factory-scopes</a></p><h2 id="1-IOC-容器-Bean的实例化"><a href="#1-IOC-容器-Bean的实例化" class="headerlink" title="1. IOC 容器 Bean的实例化"></a>1. IOC 容器 Bean的实例化</h2><p>1.1 使用静态工厂方法实例化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.ClientService&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>1.2 使用实例工厂方法实例化，使用 factory-bean 和 factory-method 去配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- the bean to be created via the factory bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createClientServiceInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultServiceLocator</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ClientService</span> <span class="hljs-variable">clientService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientServiceImpl</span>();<br><br><span class="hljs-keyword">public</span> ClientService <span class="hljs-title function_">createClientServiceInstance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> clientService;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.3 内部类</p><p>如果您在<code>com.example</code>包中有一个名为<code>SomeThing</code>的类，并且此<code>SomeThing</code>类具有一个名为<code>OtherThing</code>的<code>static</code>嵌套类，则 Bean 定义上<code>class</code>属性的值为<code>com.example.SomeThing$OtherThing</code>。 请注意，名称中使用了<code>$</code>字符以将嵌套的类名与外部类名分开</p><h2 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h2><p>)IoC 也称为依赖项注入(DI)。在此过程中，对象仅通过构造函数参数，工厂方法的参数或在构造或从工厂方法返回后在对象实例上设置的属性来定义其依赖项(即，与它们一起使用的其他对象) 。然后，容器在创建 bean 时注入那些依赖项。此过程从根本上讲是通过使用类的直接构造或诸如服务定位器模式之类的控件来控制其依赖项的实例化或位置的 bean 本身的逆过程(因此称为 Control Inversion)。</p><p>2.1 构造函数注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beanOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.ThingOne&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;beanTwo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;beanThree&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beanTwo&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.ThingTwo&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;beanThree&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.ThingThree&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.2 基于 Setter 的依赖注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.ExampleBean&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- setter injection using the nested ref element --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanOne&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanTwo&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;integerProperty&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.AnotherBean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>2.3基于工厂方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.ExampleBean&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.AnotherBean&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>2.4 一种简化配置的模式 p命名空间和c命名空间  P是属性C 是构造函数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">p:driverClassName</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">p:url</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">p:username</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">p:password</span>=<span class="hljs-string">&quot;misterkaoli&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.5 通过XML 更简洁</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mappings&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- typed as a java.util.Properties --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;properties&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>jdbc.driver.className=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/mydb<br><span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.6 支持用户创建bean对象</p><p>除了包含有关如何创建特定 bean 的信息的 bean 定义之外，<code>ApplicationContext</code>实现还允许注册在容器外部(由用户)创建的现有对象。这是通过<code>getBeanFactory()</code>方法访问 ApplicationContext 的 BeanFactory 来完成的，该方法返回 BeanFactory <code>DefaultListableBeanFactory</code>的实现。 <code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法支持此注册。但是，典型的应用程序只能与通过常规 bean 定义元数据定义的 bean 一起使用。</p><p>2.7 如果全部采用构造函数注入，则可能会导致循环依赖</p><p>三级缓存 【涉及到bean的生命周期  需要详细了解 】</p><p>2.8 延迟加载 ，首次调用的适合加载 而不是容器初始化 的时候就创建了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lazy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.ExpensiveToCreateBean&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;not.lazy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.AnotherBean&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-自动装配"><a href="#3-自动装配" class="headerlink" title="3.自动装配"></a>3.自动装配</h2><p>3.1 <em>.自动装配模式</em></p><table><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td><code>no</code></td><td>(默认)无自动装配。</td></tr><tr><td><code>byName</code></td><td>按名称注入 自动查找set方法值相同 beanId  比如setBean()   则需要有个bean对象的Id为bean</td></tr><tr><td><code>byType</code></td><td>按类型，必须包装容器里面类型只有一个，如果有多个 结合@Qualifier(value&#x3D;{beanid})</td></tr><tr><td><code>constructor</code></td><td>类似于<code>byType</code>，但适用于构造函数参数</td></tr></tbody></table><p>@autowired  注解需要开启注解 &lt;context: annotion-config &#x2F;&gt;</p><p>可以在属性上使用也可以在set上使用</p><p>@resource  先通过名字查找再通过类似查找 </p><h2 id="4-注解开发"><a href="#4-注解开发" class="headerlink" title="4.注解开发"></a>4.注解开发</h2><p>@Component ：注册为bean  mvc</p><p>衍生的 ： @Service  @Controller  @Repository  </p><p>@Scope()  作用域</p><h2 id="5-JavaConfig-Spring4-以后-核心功能"><a href="#5-JavaConfig-Spring4-以后-核心功能" class="headerlink" title="5.JavaConfig  Spring4 以后 核心功能"></a>5.JavaConfig  Spring4 以后 核心功能</h2><p>@Configuration    表示该类的主要目的是作为 Bean 定义的来源</p><p>@Bean  方法来定义 Bean 间的依赖关系</p><p>以下等价方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyService <span class="hljs-title function_">myService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acme.services.MyServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  @Configuration 注解实际也是个@component ，只不过是个特殊的配置类。类似beans.xml </p><p>@Import 多个配置类合并成一个</p><h2 id="代理与AOP"><a href="#代理与AOP" class="headerlink" title="代理与AOP"></a>代理与AOP</h2><p>代理静态代理和动态代理，动态代理实现方案有基于接口的JDK动态代理，基于类的cglib，基于字节码的javasist  Jboss服务器</p><p>代理最大好处就是解耦，抽离业务，比如 房东只负责出租房子，至于签合同 找人 等都可以找中介代理类处理</p><ul><li>基于接口的JDK动态代理 ：<ol><li>java.lang.reflect  Interface InvocationHandler</li></ol></li></ul><p>​          2.Proxy</p><p>  AOP 动态代理模式   AOP:在程序运行期间，不修改源码对已有方法进行增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.demo.demoproxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fangdong</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Rent</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runRent</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;房东租出房子&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">// 代理处理类</span><br><span class="hljs-keyword">package</span> com.demo.demoproxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>     Rent rent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRent</span><span class="hljs-params">(Rent rent)</span> &#123;<br>        <span class="hljs-built_in">this</span>.rent = rent;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  Object <span class="hljs-title function_">getProxyRent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(ProxyInvocationHandler.class.getClassLoader(),rent.getClass().getInterfaces(),<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        Object result= method.invoke(rent, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//代理处理类 和 原始类 获取到代理对象 ，执行代理方法</span><br><span class="hljs-keyword">import</span> com.demo.demoproxy.Fangdong;<br><span class="hljs-keyword">import</span> com.demo.demoproxy.ProxyInvocationHandler;<br><span class="hljs-keyword">import</span> com.demo.demoproxy.Rent;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Fangdong</span> <span class="hljs-variable">fangdong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fangdong</span>();<br>        <span class="hljs-type">ProxyInvocationHandler</span> <span class="hljs-variable">pih</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyInvocationHandler</span>();<br>        pih.setRent(fangdong);<br>        <span class="hljs-type">Rent</span> <span class="hljs-variable">proxyrent</span> <span class="hljs-operator">=</span>(Rent) pih.getProxyRent();<br>        proxyrent.runRent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="../Spring-基础/image-20230607151316319.png" alt="image-20230607151316319"> </p><p><img src="../Spring-基础/image-20230607155220408.png" alt="image-20230607155220408"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二次开发工作台</title>
    <link href="/2023/05/05/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E5%8F%B0/"/>
    <url>/2023/05/05/%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="二次开发考勤模块"><a href="#二次开发考勤模块" class="headerlink" title="二次开发考勤模块"></a>二次开发考勤模块</h1><p>基于<a href="https://doc.iocoder.cn/">https://doc.iocoder.cn/</a>  ruoyi 开发一个考勤模块，记录加班时长以及证据附件，调休记录</p><p>功能：考勤记录，记录加班 、休假的统计</p><p>安装</p><ol><li><p>redis</p></li><li><p>mysql</p></li></ol><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ol><li><p>新增模块，主项目里面pom文件增加配置</p></li><li><p>依葫芦画瓢编写controller service 和mapper</p></li></ol><p>   <img src="../二次开发工作台/image-20230620055158116.png" alt="image-20230620055158116"></p><ol start="3"><li>前端页面开发</li></ol><p>   <img src="../二次开发工作台/image-20230620055536626.png" alt="image-20230620055536626"></p><p><img src="../二次开发工作台/image-20230620055615754.png" alt="image-20230620055615754"></p><ol start="3"><li>权限、导出等直接使用ruoyi提供的注解开发</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>接口请求处理到响应的开发结构</p><ul><li>Domain &#x3D;&#x3D;&gt; VO</li><li>Controller </li><li>Services</li><li>Mapper</li></ul><p>总体就是Controller 调用 Service  service 调用Mapper。其中Service  和 Mapper先定义接口，在定义具体的实现，  通过Autowired进行类型匹配，匹配接口方便更换具体的实现</p><p>Control &#x3D;&#x3D;&gt; 类 处理前端请求 的映射 ,  前端url 到后端服务逻辑的组合的映射 </p><ul><li><p>继承一个BaseController，里面有一些常用响应处理的方法</p></li><li><p>返回的包装</p></li></ul><p>Mapper &#x3D;&#x3D;&gt; 有个EntityMapper的接口 (定义数据库ORM对象的查询)   对应有个xxMap.xml的文件 ，里面通过namespace&#x3D;”com.ruoyi.report.mapper.AttendMapper”  相对于生成了一个mapper Bean对象</p><p>Service   &#x3D;&#x3D; 接口  和 带impl的 接口的实现 ,接口定义方法 ，imp定义Service接口的实现，里面调用Mapper文件里面定义的方法</p><h2 id="开发过程中问题思考"><a href="#开发过程中问题思考" class="headerlink" title="开发过程中问题思考"></a>开发过程中问题思考</h2><ol><li><p>类似要和user表关联查询情况下，是业务表里面保存username  还是说通过userId外键关联 。前者join后效率偏低 ， 还是在service里面处理在根据ID查name</p></li><li><p>sql和java数据类型对应关系</p><p><a href="https://blog.csdn.net/weixin_44188105/article/details/129745013">https://blog.csdn.net/weixin_44188105/article/details/129745013</a></p></li><li><p>文件上传问题，方案有2种对象存储和本地的，  没有服务器，存本地，路径是配置的地址，如果是真实生产环境，地址切换问题，linux和window的磁盘路径访问问题</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Spring-boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>股票-通达信版本</title>
    <link href="/2023/04/26/%E8%82%A1%E7%A5%A8-%E9%80%9A%E8%BE%BE%E4%BF%A1%E7%89%88%E6%9C%AC/"/>
    <url>/2023/04/26/%E8%82%A1%E7%A5%A8-%E9%80%9A%E8%BE%BE%E4%BF%A1%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="股票通达信"><a href="#股票通达信" class="headerlink" title="股票通达信"></a>股票通达信</h1><p>包含工具使用、股票基本知识、常用指数规则、趋势线</p><h2 id="股票基本知识"><a href="#股票基本知识" class="headerlink" title="股票基本知识"></a>股票基本知识</h2><ul><li>5档买卖盘</li><li>集合竞价规则</li><li>k线图形态</li><li>公式意义</li><li>分红和加权</li></ul><h2 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h2><p>快捷键：</p><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>alt+f12</td><td>画线</td></tr><tr><td>ctrl+R</td><td>所属板块</td></tr><tr><td>ctrl+y</td><td>修改量价条件</td></tr><tr><td>alt+z</td><td>添加自选</td></tr><tr><td>F8</td><td>分时图 \闪电图</td></tr><tr><td>F1</td><td>帮助</td></tr><tr><td>F3</td><td>上证指数</td></tr><tr><td>F4</td><td>分析图</td></tr><tr><td>F5</td><td>K线</td></tr><tr><td>F6</td><td>自选</td></tr><tr><td>F7</td><td>功能</td></tr><tr><td>F8</td><td>切换周期</td></tr><tr><td>F9</td><td>交易</td></tr><tr><td>F10</td><td>经营数据财务报表</td></tr><tr><td></td><td></td></tr><tr><td>Ctrl+M</td><td>多图展示</td></tr><tr><td>ctrl+insert</td><td>可以添加  多指标对比</td></tr><tr><td></td><td></td></tr><tr><td>键盘精灵</td><td></td></tr><tr><td>67</td><td>涨幅榜</td></tr></tbody></table><h2 id="市场理解"><a href="#市场理解" class="headerlink" title="市场理解"></a>市场理解</h2><ol><li>价格传导的规律，小周期到大周期</li></ol><p><img src="../股票-通达信版本/image-20230502103129659.png" alt="image-20230502103129659"></p><p>需要定义在哪个周期上定义– 交易转向速度，越快速的转向越不稳定，但是也意味着一旦正确，将会获取更多利润空间</p><ol start="2"><li><p>趋势线 ，只是代表市场趋势斜率发生了变化 ，市场经常会设置此类陷阱，诱导交易，所以需要等价格创新低后交易。空头趋势走坏了，并不代表多头趋势开启。破了趋势以后最好创新低后在介入</p></li><li><p>更高的高点 和 更高的低点 不一定是上升，更低的低点 和更低的高点也不定时下降，背后时动能强弱和连续性 </p></li><li><p>价格是人们购买股票意愿的体现</p></li><li><p>交易讲证据，客观存在的东西，分析可能性和判断，不去编故事</p></li></ol><h2 id="常见做法"><a href="#常见做法" class="headerlink" title="常见做法"></a>常见做法</h2><ol><li>通过涨幅发现启动票2个点，大量买入，获取平均收益，除非第二天涨停，否则卖出</li><li>集合竞价 低价或者评价偏多，当日大概率会下跌，可以考虑做T</li><li>总市值100-200亿中间  分红不分配  看研究报告   户均流通股在增加   上市公司董事、监事、高级管理人员及相关人员持有本公司股份变动情况：</li></ol><h2 id="如何画趋势线"><a href="#如何画趋势线" class="headerlink" title="如何画趋势线"></a>如何画趋势线</h2><ol><li>支持、阻力的本质作用是体现市场共识，很多人也会画同样的线。纠结画在实体或者引线上是没意义的，重要是<strong>尽可能触碰更多K线</strong>。 另外尽量不要穿过实体</li><li>支持阻力线只有相对有效</li><li>阻力线作为卖点判断很合适</li></ol>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>股票</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql 基础</title>
    <link href="/2023/04/20/mysql-%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/04/20/mysql-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="MYSQL-基础"><a href="#MYSQL-基础" class="headerlink" title="MYSQL  基础"></a>MYSQL  基础</h1><p>关系型数据库,存储和管理数据</p><h2 id="执行图"><a href="#执行图" class="headerlink" title="执行图"></a>执行图</h2><p> 8.0版本里面直接删除了连接器，查询缓存本身消耗性能，没有缓存的时候需要新建缓存，表级锁失效慢<img src="../mysql-基础/13b8389bd9b744cb9ad4c95013821562.webp" alt="img"></p><h2 id="数据写入流程"><a href="#数据写入流程" class="headerlink" title="数据写入流程"></a>数据写入流程</h2><p><img src="../mysql-基础/image-20230420142006526.png" alt="image-20230420142006526"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>B+树，树节点存页的地址，叶子节点存的是具体数据页，数据页之间也会有一个双向链表，方便查找</p><p>聚簇索引： 非页子节点记录的是行的key ，页子节点记录的是行的信息，聚簇索引不用用户创建，mysql自动创建，一张表有且只有一个聚簇索引（主键或者第一个唯一索引unique列为key）都没有则创建一个6字节递增的隐藏列DB_ROW_ID &#x3D;&#x3D;&gt; GEN_CLUST_index的索引</p><p>非聚簇索引，（辅助索引）  页面节点保留聚簇索引的key值，在通过聚簇索引去查，也就是回表</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p>通过explain看执行计划 </p><p>type：</p><table><thead><tr><th>值（从高到低）</th><th>含义</th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>extra：</p><table><thead><tr><th>值（从高到低）</th><th>含义</th><th></th></tr></thead><tbody><tr><td>useIndex</td><td>覆盖索引</td><td></td></tr><tr><td>useIndexCondition</td><td>索引下推（需要大量回表，回表之前）</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>ref：</p><table><thead><tr><th>值（从高到低）</th><th>含义</th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="SQL事务"><a href="#SQL事务" class="headerlink" title="SQL事务"></a>SQL事务</h2><p>事务：多个数据库操作打包成一个不可分割的整体来执行，且需要保证数据的一致性、可靠性</p><p>Innodb：ACID模型，即数据库四大特性，A(Atomicity) 原子性 、C(Consistency)一致性、I(Isolation)隔离性、D(Durability)持久性, 最终是为了一致性</p><ul><li>A(Atomicity) 原子性： undo log</li><li>I(Isolation)隔离性：事务不能查看彼此未提交的数据，分为写与写的隔离（锁去解决），读与写的隔离（mvcc）</li><li>A事务读取到B事务未提交的数据  –脏读</li><li>A事务先后2次读取到数据不一致（侧重内容） – 不可重复读</li><li>A事务两次读取的数据条数不一致 （侧重数据量）–  幻读</li><li>D(Durability)持久性： 1. 断电等导致刷盘故障（内存到磁盘） redo log      2.数据页部分数据每刷过去，双写缓冲区 Double write buffer</li></ul><p><strong>隔离级别</strong></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMITTED（读未提交 RU）（当前读）（<strong>读未提交</strong>）</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ COMMITTED (读提交RC)（<strong>读已提交</strong>）</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE READ (可重复读 PR)（<strong>提交之后的也读取不到，读取刚开启事务时候数据</strong>）</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE 串行化（<strong>事务排队，不能并发</strong>）</td><td>×</td><td>×</td><td>×</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>MYISAM</strong></p><p>MYISAM就没有事务概览，由于都是非聚簇索引 ，所以不需要回表，而且没有行锁所以快，此外MYISAM还使用了一种称为“延迟键写入”的技术，这意味着它在插入数据时不会立即更新索引，而是将索引写入磁盘缓存，稍后在需要时再进行更新。这使得插入数据的速度更快，因为MYISAM不需要等待索引的更新完成。</p><p><img src="../mysql-基础/20210423165448908.png" alt="mysql数据库引擎的区别"></p><h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><p>执行器执行之前就写undo log，通过rollpointer关联 </p><p>新增Undo  更新Undo 如果有临时表，还涉及到临时表的undo log</p><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p><p>保证事务的<strong>原子性</strong></p><hr><p>著作权归所有 原文链接：<a href="https://javaguide.cn/database/mysql/mysql-logs.html">https://javaguide.cn/database/mysql/mysql-logs.html</a></p><h2 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h2><p><code>InnoDB</code>存储引擎为<code>redo log</code>的刷盘策略提供了<code>innodb_flush_log_at_trx_commit</code>参数，它支持三种策略   保证事务的<strong>持久性</strong></p><ul><li><strong>设置为0的时候，表示每次事务提交时不进行刷盘操作</strong></li><li><strong>设置为1的时候，表示每次事务提交时都将进行刷盘操作（默认值）</strong></li><li><strong>设置为2的时候，表示每次事务提交时都只把redo log buffer内容写入page cache</strong></li></ul><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p><h2 id="事务锁"><a href="#事务锁" class="headerlink" title="事务锁"></a>事务锁</h2><p>锁信息包含： 事务信息 事务ID、被锁的索引信息、锁类型模式</p><p>锁分类（lock_mode）</p><ul><li><p>LOCK_S:  共享锁  share ，也称为读锁</p></li><li><p>LOCK_X：独占锁  exclusive， 也称为写锁</p></li><li><p>LOCK_IS: 共享意向锁</p></li><li><p>LOCK_IX：独占意向锁</p></li><li><p>LOCK_AUTO_INC：自增锁  事务回滚，自增不会滚，可能导致自增不连续</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT age  FROM `big_data_500w` LOCK IN SHARE MODE ;  -- 共享锁<br>SELECT age  FROM `big_data_500w` WHERE age=20  FOR UPDATE ;  -- 排他锁<br></code></pre></td></tr></table></figure><p>锁分类（lock_type）</p><ul><li><p>表锁</p></li><li><p>行锁 </p><ul><li>rec_lock_type: 精准行锁、行GAP锁、NEXT-KEY锁、插入gap锁</li></ul></li><li><p>页锁（BDB引擎才有的）</p></li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC（Multi-Version Concurrency Control）多版本并发控制机制，解决脏读和幻读，保证隔离基础上提高了并发效率</p><p>基于undo_log以及readView读视图实现，读视图里面包含了 m_ids、min_trx_id、max_trx_id、creater_trx_id</p><p>需要理解MVCC执行顺序，为啥解决</p><p>解决不可重读：  是因为第一次创建了读视图，后续都是直接按读视图规则去读</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>网上找题目练习</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 1、取得每个部门最高薪水的人员名称 </span><br><span class="hljs-keyword">SELECT</span> <br><span class="hljs-built_in">MAX</span>(e.SAL) <span class="hljs-keyword">as</span> sal,e.DEPTNO,d.DNAME,e.ENAME<br><span class="hljs-keyword">from</span> emp e<br><span class="hljs-keyword">JOIN</span> dept d<br><span class="hljs-keyword">ON</span> e.DEPTNO<span class="hljs-operator">=</span>d.DEPTNO<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.DEPTNO<br><br><br><br><span class="hljs-comment">-- 哪些人的薪水在部门的平均薪水之上</span><br><br><span class="hljs-keyword">SELECT</span>  e1.ename, e1.sal,e1.DEPTNO,eavg.avg <span class="hljs-keyword">from</span> emp e1  <span class="hljs-keyword">JOIN</span><br><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(e.SAL) <span class="hljs-keyword">as</span> avg,DEPTNO <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.DEPTNO) eavg<br><br><span class="hljs-keyword">ON</span> eavg.DEPTNO <span class="hljs-operator">=</span> e1.DEPTNO <span class="hljs-keyword">and</span>   e1.SAL <span class="hljs-operator">&gt;</span> eavg.avg<br><br><br><br><span class="hljs-comment">-- 取得部门中（所有人的）平均的薪水等级</span><br><br><span class="hljs-keyword">select</span> salgrade.GRADE, eavg.avg,eavg.DEPTNO <br><span class="hljs-keyword">from</span> salgrade <br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(e.SAL) <span class="hljs-keyword">as</span> avg,DEPTNO <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.DEPTNO) eavg<br><span class="hljs-keyword">ON</span> eavg.avg <span class="hljs-keyword">between</span> salgrade.LOSAL <span class="hljs-keyword">and</span> salgrade.HISAL<br><br><span class="hljs-keyword">select</span> <br>e.DEPTNO , <span class="hljs-built_in">AVG</span>(s.grade)<br><span class="hljs-keyword">from</span><br>emp e<br><span class="hljs-keyword">join</span><br>salgrade s<br><span class="hljs-keyword">on</span><br>e.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal<br> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <br>e.DEPTNO<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> DEPTNO<br><br><br><span class="hljs-comment">-- 不准用组函数（Max ），取得最高薪水</span><br><br><span class="hljs-keyword">SELECT</span>  e.ENAME,e.SAL  <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> e.SAL <span class="hljs-keyword">DESC</span> limit <span class="hljs-number">1</span><br><br><br><span class="hljs-comment">-- 取得平均薪水最高的部门的部门编号</span><br><br><span class="hljs-keyword">SELECT</span> deptno, <span class="hljs-built_in">AVG</span>( emp.SAL) <span class="hljs-keyword">as</span> avg <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> avg <span class="hljs-keyword">desc</span> LIMIT <span class="hljs-number">1</span><br><br><span class="hljs-keyword">SELECT</span> vg.deptno,  <span class="hljs-built_in">MAX</span>(vg.avg) <br><span class="hljs-keyword">from</span> <br>(<span class="hljs-keyword">SELECT</span> deptno, <span class="hljs-built_in">AVG</span>( emp.SAL) <span class="hljs-keyword">as</span> avg <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> deptno) vg<br><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">WHERE</span> e.SAL <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(emp.SAL) <span class="hljs-keyword">from</span> emp) ;<br><br><br><span class="hljs-comment">-- 求平均薪水的等级最低的部门的部门名称</span><br><span class="hljs-keyword">select</span> grade <span class="hljs-keyword">from</span> salgrade <span class="hljs-keyword">where</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(sal) <span class="hljs-keyword">as</span> avgsal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> deptno <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> avgsal <span class="hljs-keyword">asc</span> limit <span class="hljs-number">1</span>) <span class="hljs-keyword">between</span> losal <span class="hljs-keyword">and</span> hisal;<br><br><span class="hljs-comment">-- 取得比普通员工(员工代码没有在 mgr 字段上出现的) 的最高薪水还要高的领导人姓名</span><br><span class="hljs-comment">-- 普通员工</span><br><span class="hljs-keyword">SELECT</span>  <span class="hljs-built_in">MAX</span>(emp.SAL) <span class="hljs-keyword">as</span> maxSal  <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">WHERE</span> emp.EMPNO  <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> emp.MGR <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">WHERE</span> emp.mgr <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">NULL</span>)<br><span class="hljs-comment">-- 领导人</span><br><br><span class="hljs-keyword">SELECT</span>  ename,sal  <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">WHERE</span> emp.EMPNO <span class="hljs-keyword">in</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> emp.MGR <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">WHERE</span> emp.mgr <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">NULL</span>)<br>  <span class="hljs-keyword">and</span> emp.SAL <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span>  <span class="hljs-built_in">MAX</span>(emp.SAL) <span class="hljs-keyword">as</span> maxSal  <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">WHERE</span> emp.EMPNO  <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> emp.MGR <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">WHERE</span> emp.mgr <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">NULL</span>)<br>)<br><br><span class="hljs-comment">-- 取得薪水最高的前五名员工</span><br><br><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span> limit <span class="hljs-number">5</span>;<br><br><br><span class="hljs-comment">-- 取得薪水最高的第六到第十名员工</span><br><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sal <span class="hljs-keyword">desc</span> limit <span class="hljs-number">5</span>,<span class="hljs-number">5</span>;<br><br><span class="hljs-comment">-- 取得最后入职的 5 名员工</span><br><br><span class="hljs-keyword">select</span> ename,hiredate <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> hiredate <span class="hljs-keyword">desc</span> limit <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">-- 取得每个薪水等级有多少员工分组count</span><br><br>   <span class="hljs-keyword">SELECT</span> GRADE, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> salgrade <span class="hljs-keyword">on</span> e.SAL <span class="hljs-keyword">BETWEEN</span> salgrade.LOSAL <span class="hljs-keyword">and</span> salgrade.HISAL <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> salgrade.GRADE <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> GRADE<br><br><span class="hljs-keyword">select</span> <br>s.grade ,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> <br>emp e <br><span class="hljs-keyword">join</span> <br>salgrade s <br><span class="hljs-keyword">on</span> <br>e.sal <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>s.grade;<br><br><span class="hljs-comment">-- 列出所有员工及领导的姓名 </span><br><span class="hljs-keyword">select</span> <br>a.ename <span class="hljs-string">&#x27;员工&#x27;</span>, b.ename <span class="hljs-string">&#x27;领导&#x27;</span><br><span class="hljs-keyword">from</span><br>emp a<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span><br>emp b<br><span class="hljs-keyword">on</span><br>a.mgr <span class="hljs-operator">=</span> b.empno;<br><br><span class="hljs-comment">-- 列出受雇日期早于其直接上级的所有员工的编号,姓名,部门名称</span><br><br><span class="hljs-keyword">SELECT</span> a.ENAME <span class="hljs-string">&#x27;员工&#x27;</span>, a.HIREDATE, b.ENAME <span class="hljs-string">&#x27;领导&#x27;</span>, b.HIREDATE ,d.DNAME<br><span class="hljs-keyword">from</span> emp a <br><span class="hljs-keyword">join</span> emp b<br><span class="hljs-keyword">on</span> a.mgr <span class="hljs-operator">=</span> b.EMPNO <span class="hljs-keyword">and</span>  a.HIREDATE<span class="hljs-operator">&lt;</span>b.HIREDATE <span class="hljs-keyword">and</span> b.ENAME <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br><span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span><br>a.deptno <span class="hljs-operator">=</span> d.deptno<br><br><br><span class="hljs-comment">-- 列出部门名称和这些部门的员工信息, 同时列出那些没有员工的部门</span><br><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> dept <br><span class="hljs-keyword">on</span> dept.deptno<span class="hljs-operator">=</span>e.deptno<br><br><span class="hljs-keyword">select</span> <br>e.<span class="hljs-operator">*</span>,d.dname<br><span class="hljs-keyword">from</span><br>emp e<br><span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span><br>e.deptno <span class="hljs-operator">=</span> d.deptno;<br><br><br><br><span class="hljs-comment">-- 列出至少有 5 个员工的所有部门按照部门编号分组，计数，筛选出 &gt;= 5</span><br><span class="hljs-keyword">SELECT</span> tt.ddname,<span class="hljs-built_in">count</span>(tt.ddname) <span class="hljs-keyword">as</span> num <br><span class="hljs-keyword">from</span> <br>(<br><span class="hljs-keyword">select</span><br>e.DEPTNO, d.dname <span class="hljs-keyword">as</span> ddname <br><span class="hljs-keyword">from</span><br>emp e<br><span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span><br>dept d<br><span class="hljs-keyword">on</span><br>e.deptno <span class="hljs-operator">=</span> d.deptno) tt<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> tt.ddname <br><span class="hljs-keyword">HAVING</span>  num <span class="hljs-operator">&gt;=</span><span class="hljs-number">5</span><br><br><br><span class="hljs-keyword">select</span> <br>emp.deptno,dept.dname<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">JOIN</span> dept <br><span class="hljs-keyword">on</span> dept.DEPTNO <span class="hljs-operator">=</span> emp.deptno<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>emp.deptno<br><span class="hljs-keyword">having</span><br><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">-- 列出薪金比&quot;SMITH&quot; 多的所有员工信息</span><br><br><span class="hljs-keyword">select</span> ename,sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SMITH&#x27;</span>);<br><br><br><span class="hljs-comment">-- 列出所有&quot;CLERK&quot;( 办事员) 的姓名及其部门名称, 部门的人数</span><br><span class="hljs-keyword">select</span> ename,job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CLERK&#x27;</span>;<br><br><br><br><br><span class="hljs-comment">-- 列出最低薪金大于 1500 的各种工作及从事此工作的全部雇员人数按照工作岗位分组求最小值。</span><br><br><span class="hljs-keyword">SELECT</span> job,<span class="hljs-built_in">MIN</span>(emp.SAL) <span class="hljs-keyword">as</span> minsal,<span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)  <span class="hljs-keyword">from</span> emp  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">HAVING</span> minsal<span class="hljs-operator">&gt;</span><span class="hljs-number">1500</span><br><br><br><br><span class="hljs-comment">-- 列出在部门&quot;SALES&quot;&lt; 销售部&gt; 工作的员工的姓名, 假定不知道销售部的部门编号</span><br><br><span class="hljs-keyword">select</span> ename <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> deptno <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SALES&#x27;</span>);<br><br><br><span class="hljs-comment">-- 列出薪金高于公司平均薪金的所有员工, 所在部门, 上级领导, 雇员的工资等级.</span><br><br><br><span class="hljs-comment">-- 列出与&quot;SCOTT&quot; 从事相同工作的所有员工及部门名称</span><br><br><span class="hljs-keyword">SELECT</span> job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">WHERE</span> emp.ENAME<span class="hljs-operator">=</span><span class="hljs-string">&#x27;SCOTT&#x27;</span><br><br><span class="hljs-keyword">SELECT</span> ENAME,d.dname,e.mgr,salgrade.GRADE <span class="hljs-keyword">from</span> emp e <br><span class="hljs-keyword">join</span> dept d<br><span class="hljs-keyword">on</span> d.deptno <span class="hljs-operator">=</span> e.deptno <br><span class="hljs-keyword">join</span> salgrade<br><span class="hljs-keyword">on</span> e.sal <span class="hljs-keyword">BETWEEN</span> salgrade.LOSAL <span class="hljs-keyword">and</span> salgrade.HISAL<br><span class="hljs-keyword">WHERE</span> e.job<span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> job <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">WHERE</span> emp.ENAME<span class="hljs-operator">=</span><span class="hljs-string">&#x27;SCOTT&#x27;</span>) <span class="hljs-keyword">and</span> e.ENAME<span class="hljs-operator">!=</span><span class="hljs-string">&#x27;SCOTT&#x27;</span><br><br><br><span class="hljs-comment">-- 列出薪金等于部门 30 中员工的薪金的其他员工的姓名和薪金.</span><br><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">SELECT</span> emp.ENAME,emp.SAL <span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">WHERE</span> emp.SAL <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> deptno <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br>)<br><span class="hljs-keyword">and</span> <br>deptno <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">30</span>;<br><br><br><span class="hljs-comment">-- 列出在每个部门工作的员工数量, 平均工资和平均服务期限 没有员工的部门，部门人数是0</span><br><br><br><span class="hljs-keyword">SELECT</span> dept.DEPTNO, <span class="hljs-built_in">COUNT</span>(emp.ename) <span class="hljs-string">&#x27;员工数&#x27;</span>, ifnull(<span class="hljs-built_in">AVG</span>( emp.SAL),<span class="hljs-number">0</span>) <span class="hljs-string">&#x27;平均薪水&#x27;</span>, ifnull(<span class="hljs-built_in">AVG</span>(TIMESTAMPDIFF(<span class="hljs-keyword">YEAR</span>,emp.HIREDATE,NOW())),<span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;平均服务年限&#x27;</span> <span class="hljs-keyword">from</span> emp <br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> dept<br><span class="hljs-keyword">on</span> emp.DEPTNO<span class="hljs-operator">=</span> dept.DEPTNO<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> emp.DEPTNO<br><br><br><span class="hljs-comment">-- 列出所有员工的姓名、部门名称和工资。</span><br><br><span class="hljs-keyword">select</span> <br>e.ename,d.dname,e.sal<br><span class="hljs-keyword">from</span><br>emp e<br><span class="hljs-keyword">join</span> <br>dept d<br><span class="hljs-keyword">on</span><br>e.deptno <span class="hljs-operator">=</span> d.deptno;<br><br><br><br><span class="hljs-comment">-- 列出所有部门的详细信息和人数</span><br><br><span class="hljs-keyword">SELECT</span> dept.LOC,dept.dname, dept.DEPTNO,dept.LOC, <span class="hljs-built_in">count</span>(emp.ename) <span class="hljs-keyword">from</span> emp  <br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> dept<br><span class="hljs-keyword">on</span> dept.DEPTNO <span class="hljs-operator">=</span>emp.DEPTNO<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept.LOC, dept.DEPTNO,dept.LOC<br><br><br><span class="hljs-comment">-- 列出各种工作的最低工资及从事此工作的雇员姓名</span><br><br><span class="hljs-keyword">select</span> <br>e.ename,t.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span><br>emp e<br><span class="hljs-keyword">join</span><br>(<span class="hljs-keyword">select</span> <br>job,<span class="hljs-built_in">min</span>(sal) <span class="hljs-keyword">as</span> minsal<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>job) t<br><span class="hljs-keyword">on</span><br>e.job <span class="hljs-operator">=</span> t.job <span class="hljs-keyword">and</span> e.sal <span class="hljs-operator">=</span> t.minsal;<br><br><br><span class="hljs-comment">-- 列出各个部门的 MANAGER( 领导) 的最低薪金</span><br><br><span class="hljs-keyword">select</span> <br>deptno, <span class="hljs-built_in">min</span>(sal)<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">where</span><br>job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MANAGER&#x27;</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>deptno;<br><br><span class="hljs-comment">-- 列出所有员工的 年工资, 按 年薪从低到高排序</span><br><br><span class="hljs-keyword">select</span> <br>ename,(sal <span class="hljs-operator">+</span> ifnull(comm,<span class="hljs-number">0</span>)) <span class="hljs-operator">*</span> <span class="hljs-number">12</span> <span class="hljs-keyword">as</span> yearsal<br><span class="hljs-keyword">from</span><br>emp<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>yearsal <span class="hljs-keyword">asc</span>;<br><br><br><span class="hljs-comment">-- 求出员工领导的薪水超过3000的员工名称与领导</span><br><span class="hljs-keyword">SELECT</span> a.ename &quot;员工&quot;, b.ename &quot;领导&quot; <span class="hljs-keyword">from</span> emp a<br><span class="hljs-keyword">join</span> emp b <br>  <span class="hljs-keyword">on</span> a.MGR<span class="hljs-operator">=</span> b.EMPNO<br>  <span class="hljs-keyword">WHERE</span> b.SAL <span class="hljs-operator">&gt;</span><span class="hljs-number">3000</span><br><br><span class="hljs-comment">-- 求出部门名称中, 带&#x27;S&#x27;字符的部门员工的工资合计、部门人数</span><br><br> <span class="hljs-keyword">SELECT</span> dept.DNAME,<span class="hljs-built_in">SUM</span>(e.sal) <span class="hljs-string">&#x27;工资合计&#x27;</span>,<span class="hljs-built_in">COUNT</span>(e.ename) <span class="hljs-string">&#x27;人数&#x27;</span>  <span class="hljs-keyword">from</span> emp e  <br> <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span>  dept<br> <span class="hljs-keyword">on</span> dept.DEPTNO<span class="hljs-operator">=</span>e.deptno <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.deptno<br><span class="hljs-keyword">HAVING</span> DNAME <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%s%&#x27;</span><br><br> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(e.sal) <span class="hljs-string">&#x27;工资&#x27;</span>,<span class="hljs-built_in">COUNT</span>(e.ename) <span class="hljs-string">&#x27;人数&#x27;</span> <span class="hljs-keyword">from</span> emp e  <br> <span class="hljs-keyword">join</span>  dept<br> <span class="hljs-keyword">on</span> dept.DEPTNO<span class="hljs-operator">=</span>e.deptno <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.deptno<br><span class="hljs-keyword">HAVING</span> dept.DNAME <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%s%&#x27;</span><br><br><span class="hljs-comment">-- 给任职日期超过 30 年的员工加薪 10%.</span><br><br><span class="hljs-keyword">update</span> emp <span class="hljs-keyword">set</span> sal <span class="hljs-operator">=</span> sal <span class="hljs-operator">*</span> <span class="hljs-number">1.1</span> <span class="hljs-keyword">where</span> timestampdiff(<span class="hljs-keyword">YEAR</span>, hiredate, now()) <span class="hljs-operator">&gt;</span> <span class="hljs-number">30</span>;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>注意sql的执行顺序</p><p>select 字段</p><p>from 表名</p><p>where …….</p><p>group by ……..</p><p>having …….</p><p>order by ……..</p><p>where  &#x3D;&gt; group by&#x3D;&gt; having&#x3D;&gt;select &#x3D;&gt;order by </p><p>分组后 只有分组的字段才有意义，其余字段没有意义，可以组合分组</p></li><li><p>设计范式</p><ul><li><p>第一范式(确保每列保持原子性)</p></li><li><p>第二范式(确保表中的每列都和主键相关)</p></li><li><p>第三范式(确保每列都和主键列直接相关,而不是间接相关)</p><p>但是数据范式不是必须的，视具体业务而定，因为过多的join 会指数级增加检索</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 解题</title>
    <link href="/2023/04/11/leetcode-%E8%A7%A3%E9%A2%98/"/>
    <url>/2023/04/11/leetcode-%E8%A7%A3%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><p>边读《labuladong的算法⼩抄》，边leetcode找几个题目练习</p><ol><li>二叉树的中序遍历【94】  <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">连接</a></li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> result= []<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">_traverse</span>(<span class="hljs-params">treeNode</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!treeNode) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-title function_">_traverse</span>(treeNode.<span class="hljs-property">left</span>)<br>         result.<span class="hljs-title function_">push</span>(treeNode.<span class="hljs-property">val</span>)<br>        <span class="hljs-title function_">_traverse</span>(treeNode.<span class="hljs-property">right</span>)<br>        <br>    &#125;<br>   <span class="hljs-title function_">_traverse</span>(root)<br>    <span class="hljs-keyword">return</span> result<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>全排列【46】  <a href="https://leetcode.cn/problems/permutations/">连接</a>   (视频参考)[<a href="https://www.bilibili.com/video/BV1P5411N7Xc/?spm_id_from=333.337.search-card.all.click%5D">https://www.bilibili.com/video/BV1P5411N7Xc/?spm_id_from=333.337.search-card.all.click]</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> permute = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">var</span> res=[]<br>    <span class="hljs-keyword">let</span> _backtack=<span class="hljs-keyword">function</span>(<span class="hljs-params">nums,track</span>) &#123;<br>        <span class="hljs-comment">// 触发结束条件</span><br>        <span class="hljs-keyword">if</span>(track.<span class="hljs-property">length</span> ==nums.<span class="hljs-property">length</span>) &#123;<br>            res.<span class="hljs-title function_">push</span>([...track])  <br>        &#125;<br>     <span class="hljs-comment">// 遍历节点    </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-property">length</span>;i++) &#123;<br>           <span class="hljs-keyword">if</span>(track.<span class="hljs-title function_">includes</span>(nums[i])) &#123;<br>               <span class="hljs-keyword">continue</span><br>           &#125;<br>           <br>            track.<span class="hljs-title function_">push</span>(nums[i])<br>            <span class="hljs-comment">// 递归查询</span><br>            <span class="hljs-title function_">_backtack</span>(nums,track)<br>            <br>           <span class="hljs-comment">// 撤销选择，将该选择加入选择列表   </span><br>            track.<span class="hljs-title function_">pop</span>()<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-title function_">_backtack</span>(nums,[])<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>N 皇后【51】 <a href="https://leetcode.cn/problems/n-queens/">连接</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">trace,row,col</span>) &#123;<br>    <span class="hljs-comment">// 检查当前位置是否可以放置皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">if</span> (trace[i][col] == <span class="hljs-string">&quot;Q&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-keyword">if</span> (trace[i][j] == <span class="hljs-string">&quot;Q&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; trace.<span class="hljs-property">length</span>; i--, j++) &#123;<br>        <span class="hljs-keyword">if</span> (trace[i][j] == <span class="hljs-string">&quot;Q&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-keyword">var</span> solveNQueens = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br> <span class="hljs-comment">// 生成N*N的处理方式</span><br> <br>  <span class="hljs-keyword">let</span> result = []<br>  <span class="hljs-keyword">let</span> trace = []  <span class="hljs-comment">// 已经放置的数据</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br>      a= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;.&#x27;</span>)<br>      trace.<span class="hljs-title function_">push</span>(a)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(trace)<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">backtrace</span> (trace,row ) &#123;<br>    <span class="hljs-keyword">if</span>(row== trace.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(trace.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>x.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)))<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        <span class="hljs-comment">// 遍历了列</span><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">isValid</span>(trace,row,i)) &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`遍历行<span class="hljs-subst">$&#123;row&#125;</span>,列<span class="hljs-subst">$&#123;i&#125;</span>`</span>)<br>        trace[row][i] =<span class="hljs-string">&#x27;Q&#x27;</span><br>        <span class="hljs-title function_">backtrace</span>(trace,row+<span class="hljs-number">1</span>)<br>        trace[row][i] = <span class="hljs-string">&#x27;.&#x27;</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-title function_">backtrace</span>(trace,<span class="hljs-number">0</span>)<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>二分查找 <a href="https://leetcode.cn/problems/binary-search/">连接</a></p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">search</span>(<span class="hljs-params"> nums ,  target </span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nums)<br>    <br>    <span class="hljs-keyword">var</span> left =<span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> right =nums.<span class="hljs-property">length</span>-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(left&lt;=right) &#123;<br>        <span class="hljs-keyword">var</span> mid =<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>( left+ (right-left)/<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span>(nums[mid]==target) &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target) &#123;<br>            left=mid+<span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target) &#123;<br>            right=mid-<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 扩展到二分靠左查询</span><br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>]<br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">findI</span>(<span class="hljs-params">arr,val</span>)&#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right= arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left&lt;=right) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`范围<span class="hljs-subst">$&#123;left&#125;</span>,<span class="hljs-subst">$&#123;right&#125;</span>`</span>)<br>        <span class="hljs-keyword">let</span> mid =<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(left+(right-left)/<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;val) &#123;<br>            right=mid-<span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]==val)&#123;<br>           right=mid-<span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&lt;val) &#123;<br>            left=mid+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 找不到场景</span><br>    <span class="hljs-keyword">if</span> (left==arr.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> arr[left] == val ? left : -<span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findI</span>(a,<span class="hljs-number">7</span>))<br><br><span class="hljs-comment">// 扩展到二分靠右查询</span><br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>]<br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">findI</span>(<span class="hljs-params">arr,val</span>)&#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right= arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left&lt;=right) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`范围<span class="hljs-subst">$&#123;left&#125;</span>,<span class="hljs-subst">$&#123;right&#125;</span>`</span>)<br>        <span class="hljs-keyword">let</span> mid =<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(left+(right-left)/<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;val) &#123;<br>            right=mid-<span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]==val)&#123;<br>           left=mid+<span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&lt;val) &#123;<br>            left=mid+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 找不到场景</span><br>    <span class="hljs-keyword">if</span> (right &lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> arr[right] == val ? right : -<span class="hljs-number">1</span>;<br> &#125;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findI</span>(a,<span class="hljs-number">7</span>))<br><br></code></pre></td></tr></table></figure></li><li><p>最小覆盖子串  <a href="https://leetcode.cn/problems/minimum-window-substring/?favorite=59jEaTgw">连接</a></p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s2</span></span><br><span class="hljs-comment"> 实际是右指针增加 左指针删除</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> checkInclusion = <span class="hljs-keyword">function</span>(<span class="hljs-params">s1, s2</span>) &#123;<br><span class="hljs-comment">// 双指针解法</span><br> <span class="hljs-keyword">var</span> left=<span class="hljs-number">0</span><br> <span class="hljs-keyword">var</span> right=<span class="hljs-number">0</span><br> <span class="hljs-keyword">var</span> valid=<span class="hljs-number">0</span><br> <span class="hljs-keyword">var</span> windowStrMap=&#123;&#125; <span class="hljs-comment">// 记录窗口字符出现次数</span><br> <span class="hljs-keyword">var</span> targetStrMap =&#123;&#125; <span class="hljs-comment">// 记录目标字符出现次数map</span><br> s1.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span> &#123;<br>    targetStrMap[x]=targetStrMap[x]||<span class="hljs-number">0</span><br>    targetStrMap[x]++<br> &#125;)<br>    <span class="hljs-keyword">var</span> s2Arr=s2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">while</span>(right&lt;s2.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">let</span> c =s2[right]<br>        <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;窗口扩大right&quot;</span>, right,targetStrMap[c])<br>        <span class="hljs-keyword">if</span>(targetStrMap[c]!=<span class="hljs-literal">undefined</span>) &#123;<br>            windowStrMap[c]=  windowStrMap[c]||<span class="hljs-number">0</span><br>            windowStrMap[c]++<br><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(windowStrMap[c],<span class="hljs-string">&quot;目标&quot;</span>,targetStrMap[c] )<br>            <span class="hljs-keyword">if</span>(windowStrMap[c]===targetStrMap[c]) &#123;<br>                valid++<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;校验数目增加&quot;</span>+valid)<br>            &#125;<br>        &#125;<br>        right++<br>        <span class="hljs-keyword">while</span>((right-left)&gt;=s1.<span class="hljs-property">length</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;验证数目：&quot;</span>+ valid + <span class="hljs-string">&quot;需要验证数目&quot;</span>+<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(targetStrMap).<span class="hljs-property">length</span> )<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;窗口缩小前left&quot;</span>, left)<br>            <span class="hljs-keyword">if</span>(valid==<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(targetStrMap).<span class="hljs-property">length</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            <span class="hljs-keyword">let</span> d= s2[left]<br>            left++<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;窗口缩小后left&quot;</span>, left)<br>            <span class="hljs-keyword">if</span>(targetStrMap[d]!=<span class="hljs-literal">undefined</span>) &#123;<br>               windowStrMap[c]=  windowStrMap[c]||<span class="hljs-number">0</span><br>                <span class="hljs-keyword">if</span>(windowStrMap[d]===targetStrMap[d]) &#123;<br>                    valid--<br>                &#125;<br>                 windowStrMap[d]--<br>                <br>            &#125;<br>        &#125;    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>二叉树的最小深度 <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">连接</a></p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一种解法递归的解法</span><br><span class="hljs-keyword">var</span> minDepth = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">left</span>==<span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-property">right</span>==<span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">left</span>!=<span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">minDepth</span>(root.<span class="hljs-property">left</span>)+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">right</span>!=<span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">minDepth</span>(root.<span class="hljs-property">right</span>)+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">left</span>!=<span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-property">right</span>!=<span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title function_">minDepth</span>(root.<span class="hljs-property">left</span>),<span class="hljs-title function_">minDepth</span>(root.<span class="hljs-property">right</span>))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//第二中BFS</span><br><br><span class="hljs-keyword">var</span> minDepth = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-comment">// 队列里面 先放进去，</span><br>   <span class="hljs-keyword">var</span> q=[] <span class="hljs-comment">// 模拟一个队列</span><br>   <span class="hljs-keyword">let</span> depth=<span class="hljs-number">1</span><br>   q.<span class="hljs-title function_">push</span>(root)<br>   <span class="hljs-keyword">while</span> (q.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-comment">// 每一次循环把下一层的树节点push进去</span><br>      <span class="hljs-keyword">let</span> length = q.<span class="hljs-property">length</span>  <span class="hljs-comment">// 这个地方得缓存这个length  因为unshift在不停更改数组 就因为这个bug</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;length;i++) &#123;<br>           item= q.<span class="hljs-title function_">shift</span>()<br>           <span class="hljs-keyword">if</span>(item&amp;&amp; item.<span class="hljs-property">left</span>==<span class="hljs-literal">null</span> &amp;&amp;item.<span class="hljs-property">right</span>==<span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">return</span> depth<br>           &#125; <br>           <span class="hljs-keyword">if</span>(item&amp;&amp;item.<span class="hljs-property">left</span>) &#123;<br>            q.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">left</span>)<br>           &#125;<br>           <span class="hljs-keyword">if</span>(item&amp;&amp;item.<span class="hljs-property">right</span>) &#123;<br>             q.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">right</span>)<br>           &#125; <br>           <br>       &#125;<br>    depth++<br>   &#125;<br>   <span class="hljs-keyword">return</span> depth<br>&#125;;<br><br></code></pre></td></tr></table></figure><ol start="7"><li><p><a href="https://leetcode.cn/problems/TVdhkn/">集合的所有子集</a> </p><p>思考： 回溯法 画图 难的是分析可遍历的结果</p><p><img src="../leetcode-解题/image-20230417182153239.png" alt="image-20230417182153239"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> subsets = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br> <span class="hljs-keyword">var</span> step = [] <span class="hljs-comment">// 临时记录选择</span><br> <span class="hljs-keyword">var</span> result= [] <span class="hljs-comment">// 记录结果</span><br> <span class="hljs-keyword">let</span> backtrack =  <span class="hljs-keyword">function</span>(<span class="hljs-params">arr,index</span>) &#123;<br>    <span class="hljs-keyword">if</span>(index&gt;=arr.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;走不通了，到底了&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=index;i&lt;arr.<span class="hljs-property">length</span>;i++) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;进入&quot;</span>,arr[i])<br>        step.<span class="hljs-title function_">push</span>(arr[i])<br>        result.<span class="hljs-title function_">push</span>([...step])<br>        <span class="hljs-title function_">backtrack</span>(arr,i+<span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;离开节点&quot;</span>,arr[i])<br>        step.<span class="hljs-title function_">pop</span>()<br>    &#125;<br> &#125;<br> <span class="hljs-title function_">backtrack</span>(nums,<span class="hljs-number">0</span>)<br> result.<span class="hljs-title function_">push</span>([])<br> <span class="hljs-keyword">return</span> result<br>&#125;;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书-labuladong的算法⼩抄</title>
    <link href="/2023/04/11/%E8%AF%BB%E4%B9%A6-labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E2%BC%A9%E6%8A%84/"/>
    <url>/2023/04/11/%E8%AF%BB%E4%B9%A6-labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E2%BC%A9%E6%8A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="读-《labuladong的算法⼩抄》"><a href="#读-《labuladong的算法⼩抄》" class="headerlink" title="读 《labuladong的算法⼩抄》"></a>读 《labuladong的算法⼩抄》</h1><p>大学时候也没上过算法课，学C++ 也只是浅尝则止。工作后也是依工作需要，复杂点的就是对树结构的遍历，以达到对数据增删改查。但是没去总结，总感觉有些更加简单、更加明确的方式去处理，让代码写的 更加清晰</p><p>现在处理项目空挡期，事不多 ，阅读阅读，豁然开朗，满满都是干货，整理下作者的一些总结，方便后面看到时候总结。其实作者全文都是干货，已经精简的不能在精简了，原文地址:  <a href="https://github.com/labuladong/fucking-algorithm">https://github.com/labuladong/fucking-algorithm</a></p><h2 id="宏观概览："><a href="#宏观概览：" class="headerlink" title="宏观概览："></a>宏观概览：</h2><p><strong>数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储）</strong>。 </p><p>至于散列表、栈、队列、堆、树、图等等各种数据结构，底层存 储⽆⾮数组或者链表</p><p>数组，连续存储，就会有扩容问题，删除和添加需要搬移后面数据保持连续，时间复杂度O(n)</p><p>链表,  不连续存储，指针指向下⼀个元素的位置，操作指针即可删除该元素或 者插⼊新元素，时间复杂度 O(1)。存储指针需要空间</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="框架思维，实际就是些根本套路"><a href="#框架思维，实际就是些根本套路" class="headerlink" title="框架思维，实际就是些根本套路"></a>框架思维，实际就是些根本套路</h3><ol><li>数组迭代：线性迭代</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 迭代访问 arr[i] &#125; &#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>链表迭代：线性迭代 、递归迭代</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val; <br>    ListNode next; <br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(ListNode head)</span> &#123; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head; p != <span class="hljs-literal">null</span>; p = p.next) &#123; <br>        <span class="hljs-comment">// 迭代访问  p.val </span><br>    &#125; <br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(ListNode head)</span> &#123; <br>    <span class="hljs-comment">// 递归访问 head.val</span><br>    traverse(head.next)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span> &#123; <br>    <span class="hljs-comment">// 前序遍历 </span><br>    traverse(root.left) <br>    <span class="hljs-comment">// 中序遍历 </span><br>    traverse(root.right)<br>    <span class="hljs-comment">// 后序遍历 </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>回溯算法   (尝试走，记录步伐，走不通就回头的算法)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">result = [] <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">路径, 选择列表</span>): <br>    <span class="hljs-keyword">if</span> 满⾜结束条件: <br>        result.add(路径) <br>        <span class="hljs-keyword">return</span> <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择 <br>        backtrack(路径, 选择列表) <br>        撤销选择<br></code></pre></td></tr></table></figure></li><li><p>⼆分搜索 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span><br><span class="hljs-comment">// 本代码还未经过力扣测试，仅供参考，如有疑惑，可以参照我写的 java 代码对比查看。</span><br><br><span class="hljs-type">var</span> <span class="hljs-variable">binary_search</span> <span class="hljs-operator">=</span> function(nums, target) &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + Math.floor((right - left) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] === target) &#123;<br>            <span class="hljs-comment">// 直接返回</span><br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 直接返回</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-type">var</span> <span class="hljs-variable">left_bound</span> <span class="hljs-operator">=</span> function (nums, target) &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + Math.floor((right - left) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] === target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定左侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断 target 是否存在于 nums 中</span><br>    <span class="hljs-comment">// 此时 target 比所有数都大，返回 -1</span><br>    <span class="hljs-keyword">if</span> (left === nums.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 判断一下 nums[left] 是不是 target</span><br>    <span class="hljs-keyword">return</span> nums[left] === target ? left : -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">var</span> <span class="hljs-variable">right_bound</span> <span class="hljs-operator">=</span> function (nums, target) &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + Math.floor((right - left) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] === target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定右侧边界</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 此时 left - 1 索引越界</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 判断一下 nums[left] 是不是 target</span><br>    <span class="hljs-keyword">return</span> nums[right] === target ? right : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>    <span class="hljs-comment">// 增⼤窗⼝</span><br>   window.add(s[right]); <br>   right++; <br>    <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>        <span class="hljs-comment">// 缩⼩窗⼝</span><br>        window.remove(s[left]); <br>        left++; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>BFS </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算从起点 start 到终点 target 的最近距离</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Node start, Node target)</span> &#123;<br>    Queue&lt;Node&gt; q; <span class="hljs-comment">// 核心数据结构</span><br>    Set&lt;Node&gt; visited; <span class="hljs-comment">// 避免走回头路</span><br>    q.offer(start); <span class="hljs-comment">// 将起点加入队列</span><br>    visited.add(start);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录扩散的步数</span><br>    <span class="hljs-keyword">while</span> (q not empty) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>        <span class="hljs-comment">/* 将当前队列中的所有节点向四周扩散 */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>            <span class="hljs-comment">/* 划重点：这里判断是否到达终点 */</span><br>            <span class="hljs-keyword">if</span> (cur is target)<br>                <span class="hljs-keyword">return</span> step;<br>            <span class="hljs-comment">/* 将 cur 的相邻节点加入队列 */</span><br>            <span class="hljs-keyword">for</span> (Node x : cur.adj()) &#123;<br>                <span class="hljs-keyword">if</span> (x not in visited) &#123;<br>                    q.offer(x);<br>                    visited.add(x);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/* 划重点：更新步数在这里 */</span><br>        step++;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="常见算法类型"><a href="#常见算法类型" class="headerlink" title="常见算法类型"></a>常见算法类型</h3><ol><li><p>动态规划（dynamic programming）</p><ul><li>动态规划一般形式就是求最值，核心问题就是穷举，但是穷举一般存在重叠子问题，所以需要备忘录或者DP table优化穷举，避免重复运算</li><li>列出状态方程</li><li>自顶向下，原始问题分解为很小的问题，最终触底，逐层返回答案，递归解法。  可以改为迭代解决，自底向上，通过缓存去缓存结果，自底到上去解决</li><li>作者举例斐不拉契数列，常规递归解决办法 时间是O(2^N) ,加备忘录之后是O(N),改为自底向上，空间复杂度直接变为O(1)</li></ul></li><li><p>回溯算法</p><ul><li><p><strong>解决⼀个回溯问题，实际上就是⼀个决策树的遍历过程</strong></p></li><li><p><strong>其核⼼就是</strong> <strong>for</strong> <strong>循环⾥⾯的递归，在递归调⽤之前「做选择」，在递归调⽤之后「撤销选择」</strong> </p></li><li><p>1、路径：也就是已经做出的选择。 </p><p>2、选择列表：也就是你当前可以做的选择。 </p><p>3、结束条件：也就是到达决策树底层，⽆法再做选择的条件。</p></li><li><p><strong>写</strong> <strong>backtrack</strong> <strong>函数时，需要维护⾛过的「路径」和当前可以做的「选择列</strong> </p><p><strong>表」，当触发「结束条件」时，将「路径」记⼊结果集</strong>。</p></li></ul></li><li><p>二分查找</p><ul><li>left + (right - left) &#x2F; 2 就和 (left + right) &#x2F; 2 的结果相同，但是有效防⽌了 left 和 right 太⼤直接相加导致溢出。 </li><li>通过已知信息尽可能多地收缩（折半）搜索空间</li><li>正常二分查找循环完毕后就是找不到了，循环结束 left&gt;right</li><li>二分靠左查找  跳出循环<ul><li>比所有的都大 left&#x3D;num.length </li><li>比所有的都小 此时left是0</li><li>范围区间但是不存在 此时arr[left]!&#x3D;val</li></ul></li><li>二分靠右查找 二分靠右边查找  跳出循环 左指针大于右指针<ul><li>比所有的都大 left&#x3D;num.length </li><li>比所有的都小 此时right是-1</li><li>范围区间但是不存在 此时arr[right]!&#x3D;val</li></ul></li></ul></li><li><p>滑动窗口</p><ul><li>注意是左闭右开</li></ul></li><li><p>双指针</p><ul><li>滑动窗口见4</li><li>环形链表</li></ul></li><li><p>BFS算法：（广度优先遍历（Breath First Search）） </p><ul><li><p>二叉树的层序遍历</p></li><li><p>DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对⾼很多。</p></li></ul><p>  你想啊，DFS 实际上是靠递归的堆栈记录⾛过的路径，你要找到最短路 </p><p>  径，肯定得把⼆叉树中所有树杈都探索完才能对⽐出最短的路径有多⻓对不 </p><p>  对？⽽ BFS 借助队列做到⼀次⼀步「⻬头并进」，是可以在不遍历完整棵 </p><p>  树的条件下找到最短距离的。 DFS 是线，BFS 是⾯</p><ul><li><p>BFS 可以找到最短距离，但是空间复杂度⾼，⽽ DFS 的空间复杂度较低</p></li><li><p>横向有个遍历 纵向也有个遍历 先纵向在横线就是深度优先 否则广度</p></li></ul></li></ol><p>二叉树：</p><p>前序遍历：根左右</p><p>中序遍历：左根右</p><p>后序遍历：左右根</p><p><img src="../读书-labuladong的算法⼩抄/image-20230412091129299.png" alt="image-20230412091129299"></p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVASE练习-飞机大战</title>
    <link href="/2023/04/03/JAVASE%E7%BB%83%E4%B9%A0-%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/"/>
    <url>/2023/04/03/JAVASE%E7%BB%83%E4%B9%A0-%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="飞机大战"><a href="#飞机大战" class="headerlink" title="飞机大战"></a>飞机大战</h1><p>自学完 Java SE  教程，网上找个项目练习下，选中了飞机大战</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>UI素材找的网上的，只不过， 网上的是用python实现的，现在用Java实现类似的功能</p><p>github :  <a href="https://github.com/yangshangqi/The-Python-code-implements-aircraft-warfare">https://github.com/yangshangqi/The-Python-code-implements-aircraft-warfare</a></p><h2 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h2><p>Swing 是 Java 为图形界面应用开发提供的一组工具包，是 Java 基础类的一部分。组件都处于<code>java.awt.Window</code> <code>javax.swing.JComponent</code> 包下</p><p>顶层：JFrame、JDialog</p><p>中间容器：JPanel、JScrollPanel、JSplitPane、JTabledPanel、JlayeredPanel</p><p>特殊容器：JMenuBar、JToolBar、JPopupMenu、JinternalFrame （内部窗口）</p><p>基本组件:  JLabel、JButton、JRadioButton、JCheckBox、JToggleButton、JTextField、JPasswordField、JTextArea、JComboBox、JList、</p><p>JProgressBar、JSlider</p><p>选取器组件:JFileChooser、JColorChooser</p><p>实际都没用到相关组件   根据点击事件的坐标判断的</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>需求分析</p><p>基础类 ：  背景图片 、位置，长、宽 ，主窗口句柄、绘制方法，</p><p>飞行类： 背景图片 、状态 、位置 、长、宽、 飞行速度，血量  ，销毁方法,主窗口句柄</p><p>玩家飞机： 继承飞行  </p><p>敌方普通飞机：继承飞行 、类的有效实体计数</p><p>敌方Boss飞机：继承飞行 </p><p>子弹：飞行类 实体</p><p>爆炸类: 爆炸效果</p><p>资源类： 音视频类</p><p>Utils类 ：</p><ul><li>敌方飞机的集合、敌方子弹的集合、所有待渲染的集合</li><li>画玩家飞机爆炸动画</li><li>画敌方飞机爆炸动画</li><li>播放音效 爆炸 声音</li></ul><p>MainWin：</p><ul><li>渲染图片、文字</li><li>启动窗口</li><li>属性: 游戏状态、</li></ul><p>多线程：</p><pre><code class="hljs">- 画图- 播放音乐</code></pre><p>功能列表</p><ul><li>玩家飞机屏幕内随便移动，无法移动出超出屏幕范围，按空格键发出子弹</li><li>敌方小飞机 1s一个 随机出现在屏幕顶部位置，且垂直落下来</li><li>敌方boss 在飞机数量达到500个后出来，地方boss击败后 显示通过</li><li>‘敌方boss 支持血量计算</li><li>我方飞机和敌方飞机碰撞 显示我方飞机爆炸图片，且播放声音</li><li>子弹和敌方飞机碰撞，且敌方飞机如果为boss飞机 敌方飞机爆炸渲染，且播放声音</li><li>随机落下来伞包，捡到伞包炸弹，按B，炸弹爆炸，界面上所有飞机都触发爆炸，大boss掉5滴血</li></ul><p>遇到问题：</p><ol><li><p>音乐播放回阻塞界面，改为多线程</p></li><li><p>抽象出的爆炸类 ，爆炸结束后需要销毁对应的 爆炸物，但是爆炸是利用Timer. schedule，一帧一帧的绘制图片 ，形成动画。需要等动画执行完毕后，在执行对应的方法。 如果是JS ，直接函数回调即可，但是JAVA不行，又不想去把实体对象传入。应该有 更加好的方式处理，最后还是把this传导进去了</p><ul><li>好像可以用线程池 + furture + callable 后面再看</li></ul></li><li><p>由于是多线程播放完动画后销毁飞机的, 所以都去读取 和删除 飞机导致最后集合列表不一致，报遍历错误</p><ul><li>ConcurrentModificationException这个错误 ，加对象锁未解决问题，可能某个敌方没加，后来直接改为了CopyOnWriteArrayList</li></ul></li><li><p>Jframe 的事件监听未重置，导致重新开始游戏的时候报错</p></li></ol><p>代码地址 ：<a href="https://github.com/godbuttton/PlanWar">https://github.com/godbuttton/PlanWar</a></p><p>执行： 安装依赖 播放声音文件，执行 Main 类的 main方法</p><p>截图如下</p><p><img src="../JAVASE练习-飞机大战/image-20230407101833410.png" alt="image-20230407101833410"></p><p><img src="../JAVASE练习-飞机大战/![](JAVASE练习-飞机大战/image-20230407101833410.png" alt="image-20230407101940293"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA SE基础</title>
    <link href="/2023/03/23/JAVA-SE%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/23/JAVA-SE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-SE（笔记）"><a href="#JAVA-SE（笔记）" class="headerlink" title="JAVA SE（笔记）"></a>JAVA SE（笔记）</h1><p>基础操作类似其余语言，不多说</p><ol><li>基本数据类型(数据类型 多了个BigDecimal  BigInteger， BigDecimal更适合需要精确计算的场景)</li><li>运算符</li><li>流程控制 （块级作用域 ，前端JS是函数作用域，ES6引入了let 才有块级作用域）<ul><li>while 语句  不止是whle() {},还可以  do {} while()  </li><li>break  如果是嵌套 可以标识跳出哪一层循环</li></ul></li></ol><p>​    </p><h2 id="基础操作练习"><a href="#基础操作练习" class="headerlink" title="基础操作练习"></a>基础操作练习</h2><ol><li><p>寻找1000以内水仙花  </p><p>也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数 ，指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;<span class="hljs-number">1000</span> ; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i%<span class="hljs-number">10</span>; <span class="hljs-comment">// 取模获取个位数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (i/<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (i/<span class="hljs-number">100</span>)%<span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> ((Math.pow(a,<span class="hljs-number">3</span>)+Math.pow(b,<span class="hljs-number">3</span>)+Math.pow(c,<span class="hljs-number">3</span>)) == (<span class="hljs-type">double</span>) i) &#123;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>斐布拉奇数列 （1000以内的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        System.out.println(a);<br>       <span class="hljs-keyword">while</span> (a+b &lt; <span class="hljs-number">1000</span>)&#123;<br>            System.out.println(b);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a+b;<br>            a =b;<br>            b= temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>基本概念同其他语言，只列出常用不一样地方以及理解</p><ol><li><p>创建对像属性都会存在初始值，如果是基本类型，那么默认是统一为<code>0</code>（如果是boolean的话，默认值为false）如果是引用类型，那么默认是<code>null</code></p></li><li><p>某个分支有return 则其余分支也需要return</p></li><li><p>按值传递</p></li><li><p>静态方法 静态变量属于类的</p><p>我们实际上是将<code>.class</code>文件丢给JVM去执行的，而每一个<code>.class</code>文件其实就是我们编写的一个类，我们在Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值，调用类的静态方法</li><li>new 创建类的实例（隐式加载）</li><li>子类初始化时</li><li>反射加载</li></ul></li><li><p>静态变量-静态代码块-成员变量-普通代码-构造方法</p></li><li><p>访问权限  <strong>共有&gt;不同包子类&gt;包内访问&gt;自己能访问</strong></p><ul><li><p>私有和公有很好理解，私有只能当前类访问，共有所有类都可以访问</p></li><li><p>默认和protected   默认就同一个包下面的类     protected 就是同一个包下面的类  + 不同包下的子类</p><p>问题： 为啥普通类不能有用protected修饰  </p><p>答案参考:  <a href="https://www.cnblogs.com/liu2687479342/p/14691339.html">https://www.cnblogs.com/liu2687479342/p/14691339.html</a></p></li></ul></li><li><p>包和文件夹是一样的 只不过建包可以一次性建好多层目录，另外标注为包后可以2层目录一个包显示，idea的功能</p></li><li><p>子类转父类，可以自动转（向上转型） 。可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类。(向下转型 )</p></li><li><p>封装-继承-多态，最精髓的多态 ，不同对象对同一个消息做出不同响应</p></li><li><p>子类重写父类的方法，不能降低可见性</p></li><li><p>抽象类 ，抽象方法，不能实例化，但是可以方便向上转型</p></li><li><p>如果一个类中有一个抽象方法，那么当前类一定是抽象类；<strong>抽象类中不一定有抽象方法</strong>。抽象方法需要有子类实现，如果子类不实现，则子类也需要定义为抽象方法</p></li><li><p>接口一定是抽象的 ，一定都是public，没有构造方法。接口有点像特殊的抽象类，没有属性，接口重要的特征就是实现<strong>类似多继承</strong> 一种方案。</p></li><li><p>包装类的缓存机制，超出缓存范围了就会new ，得到不同对象。从缓存取是同一个对象，具体可以点进去看包装类的源码。实际就是等于包装类.valueOf()</p></li><li><p>非包装类 数字等 必须要以对象方式操作，像BigInteger 等</p></li><li><p>看很多代码实现某个接口，就具备了某些功能，但是实际是个空接口,java.lang.Cloneable,告诉java这个类需要具备什么功能，打标识后，底层会做对应的处理</p></li><li><p>接口中都是抽象方法和常量，不可能有非抽象方法，常量必须被赋值。</p><ul><li><p>常量默认被public static final</p></li><li><p>方法默认被public static  abstractl修饰</p></li></ul></li><li><p>JAVA数组内存空间设计连续的，所以长度需要固定，不可以修改</p></li></ol><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是定义在另一个类中的类，内部类相比较其他语言 ，语法就有点别扭。内部类可以对同一个包中的其他类隐藏起来，有时候想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</p><ol><li><p>成员内部类</p><ul><li><p>可以无条件访问外部类的所有成员属性和成员方法</p></li><li><p>外部类必须通过成员内部类的对象来访问内部类的属性和方法</p></li><li><p>成员内部类是对象的属性，每个对象都有个内部类属性</p></li><li><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">var</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;外部类&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">var</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;内部类&quot;</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;内部类的变量--&quot;</span>+ <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span>);<br>            System.out.println(<span class="hljs-string">&quot;外部类的变量--&quot;</span>+ Outer.<span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span>);<br>            System.out.println(<span class="hljs-string">&quot;就近原则--&quot;</span>+ <span class="hljs-keyword">var</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        Outer.Inner inner= outer.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        inner.print();<br>    &#125;<br>&#125;<br><br>打印结果<br>内部类的变量--内部类<br>外部类的变量--外部类<br>就近原则--内部类<br></code></pre></td></tr></table></figure></li></ul></li><li><p>静态内部类</p><p>静态内部类就像静态方法和静态变量一样，是属于类的， <strong>内部类如果没指向外部类成员变量，将不会初始化外部类</strong>。实际会编译成2个类，有引用才会初始化类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.com.entity;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterStatic</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">var</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;外部类&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-type">String</span>  <span class="hljs-variable">var</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;静态内部类&quot;</span>;<br><span class="hljs-comment">//        无法访问外部非静态内容</span><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-keyword">var</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> src;<br><span class="hljs-keyword">import</span> src.com.entity.OuterStatic;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        OuterStatic.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterStatic</span>.Inner();<br>        inner.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>局部内部类</p><p> 方法里面的类，作用范围同其余局部变量，只能方法里面用</p></li><li><p>匿名内部类（使用频率最高）</p><p>正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。接口也是一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.com.entity;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractInner</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;抽象类&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> src;<br><span class="hljs-keyword">import</span> src.com.entity.AbstractInner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AbstractInner</span> <span class="hljs-variable">abstractInner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractInner</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-built_in">super</span>.print();<br>            &#125;<br>        &#125;;<br>        abstractInner.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Lambda表达式、</p><p>如果接口里面只有一个带实现的抽象方法，那么我们可以将匿名内部类简写为lambda表达式。lambda仅仅支持接口 不支持抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// study 是个接口</span><br><span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> ()-&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;lambada&quot;</span>);<br>        &#125;;<br>study.print();<br><span class="hljs-comment">// 方法引用语法</span><br>Study study= Interger::sum<br>Study study= String::<span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure></li><li><p>问题</p><ul><li><p>为啥局部内部类和匿名内部类只能访问final</p><blockquote><p>内部类和外部类是处于同一个级别的,内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁.</p><p>当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期</p><p>但是为什么这里用final却又可以访问呢？<br>因为Java采用了一种copy  local  variable的方式来实现，也就是说把定义为final的局部变量拷贝过来用，而引用的也可以拿过来用，只是不能重新赋值。从而造成了可以access  local  variable的假象，而这个时候由于不能重新赋值，所以一般不会造成不可预料的事情发生</p></blockquote><p>和js有区别 ，js垃圾回收是引用标志，有引用就会一直存在。</p></li></ul></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p> 异常 Exception </p><ol><li>RuntimeException 数组越界异常，空指针异常，算术异常</li><li>编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况</li></ol><p>具体右键图表</p><p><img src="../JAVA-SE基础/image-20230324170253363.png" alt="image-20230324170253363"></p><p>错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如内存溢出</p><p>当程序没有按照我们理想的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol><li>泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用的</li><li>引入泛型，可以提高代码的可重用性</li><li>泛型类型限定(泛型类和泛型方法都可以使用类型限定)</li><li>泛型通配符？形如&lt;? extends 类名&gt;&lt;? super 类名&gt; </li><li>编译器在编译时会进行泛型擦除，未定义上下限的就是Object，但是会有一个signature弱标记，这也是能通过反射拿到泛型具体类型的原因</li></ol><h2 id="函数式编程工具接口"><a href="#函数式编程工具接口" class="headerlink" title="函数式编程工具接口"></a>函数式编程工具接口</h2><ol><li><p>Supplier  生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Supplier &lt;Integer&gt;  supplier = ()-&gt; &#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">55</span>;<br>&#125;;<br>System.out.println(supplier.get());<br></code></pre></td></tr></table></figure></li><li><p>Consumer  很常用，    其实和JS里面的回调有点类似，可以把参数给第三方函数去消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;Integer&gt; consumer = (a)-&gt; &#123;<br>           System.out.println(a);<br>       &#125;;<br>       consumer.andThen(x-&gt; &#123;<br>       &#125;).accept(<span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure></li><li><p>Function    先执行compose  apply 在执行andThen   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Function &lt;Number, String&gt; nfunction = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Number, String&gt;() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(Number number)</span> &#123;<br>             <span class="hljs-keyword">return</span> number.toString();<br>         &#125;<br>     &#125;;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;444&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nfunction<br>            .compose(String::length)<br>            .andThen(s-&gt; &#123;<br>                System.out.println(s.toUpperCase());<br>                <span class="hljs-keyword">return</span> s.concat(<span class="hljs-string">&quot;拼接&quot;</span>);<br>            &#125;)<br>            .apply(<span class="hljs-string">&quot;3333&quot;</span>);<br>    System.out.println(n);<br></code></pre></td></tr></table></figure></li><li><p>Predicate  .test() 返回bool值   .and .nagate .or 等逻辑运算，语义化</p></li><li><p>optional  判断空</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">Optional<span class="hljs-selector-class">.ofNullable</span>(i)<span class="hljs-selector-class">.ifPresent</span>(s -&gt; &#123;<br>    System.out.println(s);<br>&#125;)<span class="hljs-selector-class">.orElse</span>(s-&gt; &#123;&#125;)<span class="hljs-selector-class">.orElseGet</span>()<br></code></pre></td></tr></table></figure></li></ol><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p> 一般使用接口<code>List&lt;E&gt;</code>,方便后面Array改Linked等 切换</p><ol><li><p>ArrayList  底层是数组实现的 用size记录长度，动态改变size和存储内容 </p><p>tips： ArrayList  实现里面有个 transient Object[] elementData  </p><blockquote><p>java语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。</p><p>Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据 成员，我们不想用serialization机制来保存它。****为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字 transient****。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的</p></blockquote></li></ol><p>​<img src="../JAVA-SE基础/image-20230328140645246.png" alt="image-20230328140645246"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 转化为ArrayList</span><br>      List&lt;String&gt; arrayList1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;第一个元素&quot;</span>,<span class="hljs-string">&quot;第二个元素&quot;</span>));<br>      System.out.println(arrayList1.toString());<br>   arrayList1.removeIf(x-&gt;x.contentEquals(<span class="hljs-string">&quot;第一个元素&quot;</span>));<br><br><br>System.arraycopy();<br>Arrays.copyOf <br><br><br></code></pre></td></tr></table></figure><ol start="2"><li>LinedList</li></ol><p><img src="../JAVA-SE基础/image-20230328145639936.png" alt="image-20230328145639936"></p><ol start="3"><li>iterator 迭代器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; iterator =  arrayList1.iterator();<br>   <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>       System.out.println(iterator.next());<br>   &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>队列 Dueue 队列接口 Deque 双端队列接口。通常将LinkedList当队列使用</p><p><img src="../JAVA-SE基础/image-20230328152628905.png" alt="image-20230328152628905"></p><ul><li><p>add 会报异常</p></li><li><p>offer 同add 返回bool</p></li><li><p>remove 移除队首 会报异常</p></li><li><p>poll 移除队首 队列为空会返回null</p></li><li><p>element 获取队首元素 会报异常</p></li><li><p>peek 获取队首 为空会返回null</p></li><li><p>Deque 和前端有点像 子接口 功能更加强大</p><p><img src="../JAVA-SE基础/image-20230328153206398.png" alt="image-20230328153206398"></p></li></ul></li><li><p>优先级队列 PriorityQueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt; &#123;<br>          <span class="hljs-keyword">return</span> b-a;<br>      &#125;);<br>      q.offer(<span class="hljs-number">3</span>);<br>      q.offer(<span class="hljs-number">1</span>);<br>      q.offer(<span class="hljs-number">2</span>);<br>      System.out.println(q.poll());<br>      System.out.println(q.poll());<br>      System.out.println(q.poll());<br></code></pre></td></tr></table></figure></li><li><p>Set 同js  不重复  不支持随机访问（不允许下标访问）</p><p>底层是hash散列，所以无序存储的，HashSet  ，  </p><p>如果需要遍历顺序保持和插入时候一致 用TreeSet 和 LinkedHashSet</p><p>TreeSet  可以传入一个compare 指定排序规则</p><p>顺便记录下测试时候写的 一个bug，预估的是打印3个，结果吞掉一个，</p><p><img src="../JAVA-SE基础/image-20230328174950429.png" alt="image-20230328174950429"></p><p>原因是 底层采用了HashMap，用Map的key保存set的value值，但是Map的value是Present，finale new Object(),</p><p>add 时候 进行比较 结果是0，只更新了相同key的 value值，未更新key值 。 最终set取的是map的key值，所以导致丢失</p><p><img src="../JAVA-SE基础/image-20230328180511344.png" alt="image-20230328180511344"></p><p>reeSet&#x2F;TreeMap集合  自平衡二叉树  中序遍历</p><p><img src="../JAVA-SE基础/image-20230328162133193.png" alt="image-20230328162133193"></p></li></ol><p>​</p><ol start="7"><li>Map 键值对存储  具体查文档</li></ol><h2 id="集合Stream-流以及集合工具类"><a href="#集合Stream-流以及集合工具类" class="headerlink" title="集合Stream 流以及集合工具类"></a>集合Stream 流以及集合工具类</h2><p>集合流和IO流是2种东西，集合流是对集合增强的一个东西，总体流程</p><p>集合 -&gt; 数据流-&gt;转换操作-&gt;终点操作   或者短路操作</p><p><strong>转换操作</strong>：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel</p><p><strong>终点操作</strong>：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny</p><p><strong>短路操作：</strong> anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit.</p><p>demo </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="hljs-string">&quot;abb&quot;</span>,<span class="hljs-string">&quot;dwwddw&quot;</span>,<span class="hljs-string">&quot;A-feefed&quot;</span>,<span class="hljs-string">&quot;D-ddd&quot;</span>));<br>   list.add(<span class="hljs-string">&quot;A-dd&quot;</span>);<br>   <span class="hljs-type">Collection</span> <span class="hljs-variable">collection</span> <span class="hljs-operator">=</span> list<br>           .stream()<br>           .filter(x-&gt;&#123;<br>               <span class="hljs-keyword">return</span> x.length()&gt;<span class="hljs-number">2</span>;<br>           &#125;)<br>           .distinct()<br>           .map(x-&gt;x.length())<br>           .sorted()<br>           .collect(Collectors.toList());<br>   System.out.println(collection.toString());<br></code></pre></td></tr></table></figure><p>有点类似Javascript的 函数式编程，确实方便许多，API查文档</p><h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p>输入流是读取  输出流是write</p><ol><li><p>输入、输出字节流          FileInputStream FileOutputStream </p></li><li><p>输入、输出字符流         FileReader  FileWriter</p></li><li><p>缓存文件流           BufferedInputStream BufferedOutputStream   close或者flush或者缓存区满了 就会保存到数组里面</p></li><li><p>转换流                 InputStreamReader和OutputStreamWriter本质也是Reader和Writer，可以转化为其他流</p></li><li><p>打印流             PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制 类似还有个Scanner 输入</p></li><li><p>数据流       DataInputStream 最大的不同是它支持基本数据类型的直接读取</p></li><li><p>对象流      ObjectOutputStream  ObjectInputStream  不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO</p></li></ol><p>网上找到图片  很全 </p><p><img src="../JAVA-SE基础/0892164c86594a9eb1929f0d8205ff95.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IOTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;testcopy.txt&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">printWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-string">&quot;textPrint.txt&quot;</span>);<br>        printWriter.print(<span class="hljs-string">&quot;我在测试字段&quot;</span>);<br>        printWriter.close();<br>        System.out.println(<span class="hljs-string">&quot;请输入数据&quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.print(<span class="hljs-string">&quot;请输入第一个字符串：&quot;</span>);<br>        String s1=scanner.nextLine();<br><br>        System.out.print(<span class="hljs-string">&quot;请输入第二个字符串：&quot;</span>);<br>        String s2=scanner.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;输入的字符串是：&quot;</span>+s1+<span class="hljs-string">&quot;和 &quot;</span>+s2);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span>fileReader.read();<br>        <span class="hljs-keyword">while</span> (!c.equals(-<span class="hljs-number">1</span>)) &#123;<br>            fileWriter.write(c);<br>            c =  fileReader.read();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>        fileReader.close();<br>        fileWriter.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程入门  Thread, 构造函数入参 传入一个Runnable接口的实现类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">150</span>;i++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;AThread&quot;</span>+Thread.currentThread().getName() +<span class="hljs-string">&quot;-&quot;</span> + i+  <span class="hljs-string">&quot;打印&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">150</span>;j++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;BThread&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;-&quot;</span> + j+<span class="hljs-string">&quot;-打印&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程状态  </p><p>新生状态(New)    就绪状态(Runnable)   运行状态(Running)   阻塞状态(Blocked)   死亡状态(Terminated)</p><p>转化如下</p><p><img src="../JAVA-SE基础/image-20230330095258279.png" alt="image-20230330095258279"></p><ol><li><p>每一个Thread对象中，都有一个<code>interrupt()</code>方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的<code>stop()</code>方法是强制终止线程，interrupted 复位，清楚标识继续运行</p></li><li><p>Thread.currentThread().suspend();      Thread.currentThread().resume();   <em>&#x2F;&#x2F;恢复此线程</em> <em>&#x2F;&#x2F;暂停此线程</em>    次方法不推荐了</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//interrupt()方法 如果执行种可以通过isInterrupted()获取是否中断标识  如果处于休眠状态 通过try catch获取异常抛出在处理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程休眠结束&quot;</span>);<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="hljs-comment">//判断是否存在中断标志</span><br>                        System.out.println(<span class="hljs-string">&quot;线程中断interrupt&quot;</span>);<br>                        <span class="hljs-comment">// break;</span><br>                        Thread.interrupted();  <span class="hljs-comment">//复位</span><br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;正常执行&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        System.out.println(<span class="hljs-string">&quot;主线程休眠开始&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">//主线程休眠2s</span><br>        thread.interrupt();<br>        System.out.println(<span class="hljs-string">&quot;主线程休眠结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>线程的优先级</p><p>​Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源</p><ul><li>MIN_PRIORITY 最低优先级</li><li>MAX_PRIORITY 最高优先级</li><li>NOM_PRIORITY 常规优先级</li><li>thread.setPriority(Thread.MIN_PRIORITY);</li><li>优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！</li></ul></li><li><p>线程的礼让和加入</p><p> thread.yield();   将CPU资源让位给其他线程</p><p> thread.join();   加入到当前线程  一个线程等待另一个线程执行完成后再继续进行，</p></li><li><p>线程锁和线程的同步</p><p><img src="../JAVA-SE基础/image-20230330112609079.png" alt="image-20230330112609079"></p><p>多线程共同读写主内存里面的东西，由于有缓存，每个线程都从主内存copy到工作内存，在工作内存修改后同步到主内存。会导致A线程已经修改了某个变量，但是没同步到主内存，而 B线程已经读取这个变量到缓存里面，缓存里面的这个变量就不一致了，写回主内存就不一样</p><p>于是 引入了缓存一致性问题，</p><p>于是引入 synchronized关键字来创造一个线程锁</p><p>synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类,本质上都是对象锁，类锁实际也是锁的类的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedThread</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">itempI</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread Thread1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (SynchronizedThread.class) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10000</span>;j++) &#123;<br>                    i++;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        Thread Thread2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           <span class="hljs-keyword">synchronized</span> (SynchronizedThread.class) &#123;<br>               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10000</span>;j++) &#123;<br>                    i++;<br>                   &#125;<br>           &#125;<br>        &#125;);<br>        Thread1.start();<br>        Thread2.start();<br>        sleep(<span class="hljs-number">3000</span>);<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>锁还可以加在方法上  <strong>如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedThread</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">itempI</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add1</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread Thread1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10000</span>;j++) &#123;<br>                add1();<br>            &#125;<br>        &#125;);<br>        Thread Thread2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10000</span>;j++) &#123;<br>             add1();<br>           &#125;<br>        &#125;);<br>        Thread1.start();<br>        Thread2.start();<br>        sleep(<span class="hljs-number">3000</span>);<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>死锁，如下图，两个线程相互持有对方需要的锁，但是又迟迟不释放</p><p><img src="../JAVA-SE基础/image-20230330120202335.png" alt="image-20230330120202335"></p></li><li><p>要在synchronized里面使用</p><p>await： 当前线程进入等待状态，并且释放对象锁   可以设置最大等待时间 </p><p>notify： 随机唤起一个    且在notify后，当前线程不会马上释放锁，要等到当前线程被synchronized修饰的代码执行完，才会释放锁；</p><p>notifyall： 唤起所有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        Thread Thread1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                System.out.println(<span class="hljs-string">&quot;执行Thread1 流程&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;开始释放锁&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    o.wait(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;执行完毕Thread1结束&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">Thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                System.out.println(<span class="hljs-string">&quot;开始执行Thead2&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;通知不用等待了&quot;</span>);<br>                o.notify();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;执行完毕Thread2 流程&quot;</span>);<br>            &#125;<br>        &#125;);<br>        Thread1.start();<br>        Thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ThreadLocal</p><ul><li>可以使用ThreadLocal类，为当前线程存值</li><li>InheritableThreadLocal  只是继承初始值  作用域和ThreadLocal一样</li></ul></li><li><p>定时任务   timeTask是个实现了Runnable的抽象类，不是个接口 ，没法用lambda表达式。。。感觉好累赘</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        java.util.<span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Timer();<br>        <span class="hljs-keyword">final</span> Integer[] a = &#123;<span class="hljs-number">0</span>&#125;;<br>        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                a[<span class="hljs-number">0</span>]++;<br>                <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == <span class="hljs-number">10</span>) &#123;<br>                    timer.cancel();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;延迟1s执行 后面每隔2s执行一次&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-number">1000</span>,<span class="hljs-number">2000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>守护线程</p><p>Daemon英文意思是希腊神话中半人半神的精灵，守护神。在java中，”精灵守护Daemon线程”就是运行在程序后台的线程，一般被用于在后台为其它线程提供服务。既然它在后台运行，当前台线程（前几节学习的线程）运行完，主体程序就结束了，理所当然该后台线程也应该随之结束了</p><p>当一个应用程序的所有非精灵线程停止运行时，应用程序也将终止，守护线程自动停止</p><p>t.setDaemon(true);   <em>&#x2F;&#x2F;设置为守护线程（必须在开始之前，中途是不允许转换的）</em> </p></li><li><p>并行方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">parallerlCollect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="hljs-string">&quot;1-fef&quot;</span>,<span class="hljs-string">&quot;2-dewdw&quot;</span>,<span class="hljs-string">&quot;3-frfrfrf&quot;</span>,<span class="hljs-string">&quot;4-fef&quot;</span>,<span class="hljs-string">&quot;5-dewdw&quot;</span>,<span class="hljs-string">&quot;6-frfrfrf&quot;</span>,<span class="hljs-string">&quot;7-fef&quot;</span>,<span class="hljs-string">&quot;8-dewdw&quot;</span>,<span class="hljs-string">&quot;43-frfrfrf&quot;</span>));<br>        list.parallelStream().forEach((ele)-&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + ele);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 集合类并发安全（   java.util.concurrent.）</p></li></ol><h2 id="JAVA-SE练习"><a href="#JAVA-SE练习" class="headerlink" title="JAVA SE练习"></a>JAVA SE练习</h2><ol><li>游戏开发 <a href="https://godbuttton.github.io/2023/04/03/JAVASE%E7%BB%83%E4%B9%A0-%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/">飞机大战</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鼠标移动脚本</title>
    <link href="/2023/03/21/%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/03/21/%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="用chart-GPT写的一个脚本，太厉害了-感觉要失业了"><a href="#用chart-GPT写的一个脚本，太厉害了-感觉要失业了" class="headerlink" title="用chart-GPT写的一个脚本，太厉害了 感觉要失业了"></a>用chart-GPT写的一个脚本，太厉害了 感觉要失业了</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><br><span class="hljs-comment"># 获取当前时间</span><br><span class="hljs-variable">$currentTime</span> = <span class="hljs-built_in">Get-Date</span><br><br><span class="hljs-comment"># 计算距离下一个 3 分钟的时间</span><br><span class="hljs-variable">$secondsUntilNext3Min</span> = (<span class="hljs-number">3</span> - <span class="hljs-variable">$currentTime</span>.Minute % <span class="hljs-number">3</span>) * <span class="hljs-number">60</span> - <span class="hljs-variable">$currentTime</span>.Second<br><br><span class="hljs-comment"># 计算下一个 3 分钟的时间</span><br><span class="hljs-variable">$next3MinTime</span> = <span class="hljs-variable">$currentTime</span>.AddSeconds(<span class="hljs-variable">$secondsUntilNext3Min</span>)<br><br><span class="hljs-comment"># 循环执行移动鼠标和点击操作</span><br><span class="hljs-keyword">while</span> (<span class="hljs-variable">$true</span>) &#123;<br>    <span class="hljs-comment"># 等待到下一个 3 分钟的时间</span><br>    <span class="hljs-variable">$timeToWait</span> = <span class="hljs-variable">$next3MinTime</span> - (<span class="hljs-built_in">Get-Date</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$timeToWait</span>.TotalSeconds <span class="hljs-operator">-gt</span> <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">Start-Sleep</span> <span class="hljs-literal">-Seconds</span> <span class="hljs-variable">$timeToWait</span>.TotalSeconds<br>    &#125;<br><br>    <span class="hljs-comment"># 等待一段时间</span><br>    <span class="hljs-built_in">Start-Sleep</span> <span class="hljs-literal">-Seconds</span> <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 阻止屏幕锁屏</span><br>    <span class="hljs-variable">$o</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-ComObject</span> wscript.shell<br>    <span class="hljs-variable">$o</span>.sendkeys(<span class="hljs-string">&quot;&#123;SCROLLLOCK&#125;&#123;SCROLLLOCK&#125;&quot;</span>)<br><br>    <span class="hljs-comment"># 获取当前时间</span><br>    <span class="hljs-variable">$currentTime</span> = <span class="hljs-built_in">Get-Date</span><br><br>    <span class="hljs-comment"># 计算距离下一个 3 分钟的时间</span><br>    <span class="hljs-variable">$secondsUntilNext3Min</span> = (<span class="hljs-number">3</span> - <span class="hljs-variable">$currentTime</span>.Minute % <span class="hljs-number">3</span>) * <span class="hljs-number">60</span> - <span class="hljs-variable">$currentTime</span>.Second<br><br>    <span class="hljs-comment"># 计算下一个 3 分钟的时间</span><br>    <span class="hljs-variable">$next3MinTime</span> = <span class="hljs-variable">$currentTime</span>.AddSeconds(<span class="hljs-variable">$secondsUntilNext3Min</span>)<br><br>    <span class="hljs-comment"># 判断是否到了晚上 18:30，如果是，则关闭计算机</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$currentTime</span>.Hour <span class="hljs-operator">-eq</span> <span class="hljs-number">18</span> <span class="hljs-operator">-and</span> <span class="hljs-variable">$currentTime</span>.Minute <span class="hljs-operator">-ge</span> <span class="hljs-number">30</span>) &#123;<br>        <span class="hljs-built_in">Stop-Computer</span><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>摸鱼脚本。如果当前时间晚于下午6点，则脚本将关闭电脑。你可以通过运行 <code>nohup ./script.sh &amp;</code> 命令将其作为后台进程运行，并使用 <code>kill PID</code> 命令停止它。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发工具</title>
    <link href="/2023/03/20/%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"/>
    <url>/2023/03/20/%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="工具、开发环境集合"><a href="#工具、开发环境集合" class="headerlink" title="工具、开发环境集合"></a>工具、开发环境集合</h1><p>收集开发过程中的配置、插件、工具站点</p><h2 id="工具站点收集"><a href="#工具站点收集" class="headerlink" title="工具站点收集"></a>工具站点收集</h2><table><thead><tr><th>描述</th><th>站点</th><th></th></tr></thead><tbody><tr><td>生成控制台字符串</td><td><a href="http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20">http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type%20Something%20</a></td><td></td></tr><tr><td>压缩图片</td><td><a href="https://tinify.cn/">https://tinify.cn/</a></td><td></td></tr><tr><td>SQL生成</td><td><a href="https://www.sqlkiller.com/">https://www.sqlkiller.com/</a></td><td></td></tr><tr><td>javaguide</td><td><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">https://javaguide.cn/java/basis/java-basic-questions-01.html</a></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="学习站点收集"><a href="#学习站点收集" class="headerlink" title="学习站点收集"></a>学习站点收集</h2><table><thead><tr><th>描述</th><th>站点</th><th></th></tr></thead><tbody><tr><td>learnGit</td><td><a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></td><td></td></tr><tr><td>learnSql</td><td><a href="https://sqlzoo.net/">https://sqlzoo.net/</a></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="常用开发工具"><a href="#常用开发工具" class="headerlink" title="常用开发工具"></a>常用开发工具</h2><table><thead><tr><th>软件名</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>VSCODE</td><td>前端开发</td><td></td></tr><tr><td>Intellij Idea</td><td>Java开发</td><td></td></tr><tr><td>Postman</td><td>工具调用接口</td><td>方便前置脚本、登录、Token等</td></tr><tr><td>Typero</td><td>笔记</td><td></td></tr><tr><td>SourceTree</td><td>git图形化工具</td><td>类似小乌龟</td></tr><tr><td>navicat</td><td>数据库管理工具</td><td></td></tr><tr><td>Xshell</td><td>连接服务器</td><td></td></tr><tr><td>XFtp</td><td>上传文件</td><td></td></tr><tr><td>fiddler</td><td>抓包</td><td>PS：有时候js文件太大 chrome解析不出来的时候<br />可以拦截后映射为本地文件，会影响其它功能软件</td></tr><tr><td>pycharm</td><td>python开发调试</td><td></td></tr><tr><td>utools</td><td>效率神器</td><td>集成各种插件 简直就是效率神器</td></tr><tr><td>Ditto</td><td>剪切板神器</td><td>可与查看最近几次剪切的内容</td></tr><tr><td>Nvm</td><td>管理node版本</td><td>方便切换和管理node nvm-window</td></tr></tbody></table><h2 id="Intellij-Idea-常用插件"><a href="#Intellij-Idea-常用插件" class="headerlink" title="Intellij Idea  常用插件"></a>Intellij Idea  常用插件</h2><table><thead><tr><th>插件名</th><th>用处</th><th>备注</th></tr></thead><tbody><tr><td>Translation</td><td>随时翻译</td><td></td></tr><tr><td>Alibaba Java Code Guidelines</td><td>阿里巴巴 Java 代码规范，帮助你代码更符合规范，建议安装后将语言替换为中文，提示更加人性。</td><td>在 idea 中双击 shit 输入 阿里，切换中英文</td></tr><tr><td>CodeGlance3</td><td>生成代码地图</td><td></td></tr><tr><td>MyBatisX</td><td>IDEA 的快速开发插件，方便在使用mybatis以及mybatis-plus开始时简化繁琐的重复操作</td><td></td></tr><tr><td>Search In Repository</td><td>把 Maven 的中央仓库的查找功能集成到 idea 中</td><td></td></tr><tr><td>GSONFormat</td><td>可以利用 GsonFormat插件，解析Json格式数据快速创建符合 Gson要求的 JavaBean</td><td></td></tr><tr><td>Maven Helper</td><td>开发过程中，我们难免会遇到各种jar包冲突，Maven Helper可以很方便的找到和排除冲突的依赖。</td><td></td></tr><tr><td>Grep Console</td><td>控制台日志颜色</td><td></td></tr><tr><td>chinese simple</td><td>语言包</td><td></td></tr></tbody></table><h2 id="vscode-常用插件"><a href="#vscode-常用插件" class="headerlink" title="vscode 常用插件"></a>vscode 常用插件</h2><table><thead><tr><th>插件名</th><th>用处</th><th>备注</th></tr></thead><tbody><tr><td>vscode-icons</td><td>主题图标</td><td></td></tr><tr><td>Chinese (Simplified)</td><td>编辑器中文语言包</td><td></td></tr><tr><td>Codelf</td><td>给变量起名的神器</td><td></td></tr><tr><td>Prettier</td><td>格式化代码</td><td></td></tr><tr><td>css-auto-prefix</td><td>自动补全、内核兼容性处理</td><td></td></tr><tr><td>CSS Peek</td><td>查看样式</td><td></td></tr><tr><td>LeetCode</td><td>刷题</td><td></td></tr><tr><td>gitLengths</td><td>查看代码提交人</td><td></td></tr><tr><td>Atom One Dark Theme</td><td>主题</td><td></td></tr><tr><td>Auto Close Tag</td><td>自动合并标签</td><td></td></tr><tr><td>Path Intellisense</td><td>相对路径自动补全</td><td></td></tr><tr><td>Snippets</td><td>提示代码片段</td><td></td></tr><tr><td>Volar</td><td>vue官方推荐的vue feature扩展</td><td></td></tr></tbody></table><h2 id="个人习惯的一套快捷键"><a href="#个人习惯的一套快捷键" class="headerlink" title="个人习惯的一套快捷键"></a>个人习惯的一套快捷键</h2><h3 id="vscode（装Eclipse-keymap）"><a href="#vscode（装Eclipse-keymap）" class="headerlink" title="vscode（装Eclipse keymap）"></a>vscode（装Eclipse keymap）</h3><table><thead><tr><th>快捷键</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="Intellij-idea-Eclipse-keymap）"><a href="#Intellij-idea-Eclipse-keymap）" class="headerlink" title="Intellij idea (Eclipse keymap）"></a>Intellij idea (Eclipse keymap）</h3><table><thead><tr><th>快捷键</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>ALT+INSERT</td><td>生成代码</td><td></td></tr><tr><td>SHIFT+SHIFT</td><td>找文件 找类</td><td></td></tr><tr><td>CTRL +H</td><td>文件查找代码</td><td></td></tr><tr><td>CTRL+O</td><td>预览对象属性和方法</td><td></td></tr><tr><td>F4</td><td>查看继承关系</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wife And Baby Care</title>
    <link href="/2023/03/19/Wife%20And%20Baby%20Care/"/>
    <url>/2023/03/19/Wife%20And%20Baby%20Care/</url>
    
    <content type="html"><![CDATA[<h1 id="Wife-And-Baby-Care"><a href="#Wife-And-Baby-Care" class="headerlink" title="Wife And Baby Care"></a>Wife And Baby Care</h1><p>新手奶爸，不清楚该做啥事 ，整理下注意事项</p><h2 id="分娩前症状"><a href="#分娩前症状" class="headerlink" title="分娩前症状"></a>分娩前症状</h2><ul><li>不规律的宫缩 （初次间隔5-6min）(经产妇间隔5-6min)每次 持续20s</li><li>见红 一般24小时 个别几天甚至一周后生产</li><li>破水：阴道流出像尿一样多的水 带点腥味，不能自己控制 。 及时去医院，取卧位，太高臀部，以防止羊水流出，导致脐带脱落，胎儿窒息，甚至胎死</li><li>产前有便意，胎儿头部压缩直肠，部分孕妇会有压迫性刺激，部分孕妇便意增加，需要注意不要用力 ，以免宫颈裂伤现象</li></ul><h2 id="待产准备"><a href="#待产准备" class="headerlink" title="待产准备"></a>待产准备</h2><ol><li><p>孕妈妈准备</p><ul><li><input disabled="" type="checkbox"> 换洗衣服 分娩体型有变化</li><li><input disabled="" type="checkbox"> 方便哺乳衣服</li><li><input disabled="" type="checkbox"> 卫生巾、卫生纸、洗漱用品</li><li><input disabled="" type="checkbox"> 产褥垫、防溢褥垫</li><li><input disabled="" type="checkbox"> 餐具被子吸管</li><li><input disabled="" type="checkbox"> 产检报告 身份证 医保卡</li></ul></li><li><p>宝宝准备</p><ul><li><input disabled="" type="checkbox"> 包被、奶瓶、小毛巾</li><li><input disabled="" type="checkbox"> 新生儿衣服、湿纸巾</li><li><input disabled="" type="checkbox"> 小杯、小勺、尿不湿、润肤乳</li></ul></li></ol><h2 id="生产过程"><a href="#生产过程" class="headerlink" title="生产过程"></a>生产过程</h2><ol><li>【第一产程】 规律宫缩到宫口全开10cm 初产妇11-12小时 </li><li>【第二产程】 宫口全开至胎儿娩出 初产妇30分钟到2小时</li><li>【第三产程】 胎儿娩出至胎盘胎膜娩出 5-30分钟</li></ol><p>​</p><h2 id="产妇饮食原则以及禁忌"><a href="#产妇饮食原则以及禁忌" class="headerlink" title="产妇饮食原则以及禁忌"></a>产妇饮食原则以及禁忌</h2><p>1.产后饮食原则</p><pre><code class="hljs">- 一清  排恶露，加强肾脏排泄功能- 二温  预防腰酸背痛，促进子宫收缩良好- 三补  强补气血，增强体力，预防产后老化。补养腰膝，催乳发奶</code></pre><p>2.产后应摄取的食物</p><ul><li>一周之后可以摄取高蛋白食物</li><li>多补充纤维素，对吃水果蔬菜</li><li>多吃含铁食物补血</li><li>盐分摄入量减少</li></ul><p>3.产后饮食禁忌</p><ul><li>忌过早大量喝汤以及浓汤</li><li>忌喝红糖水太多</li><li>忌饮茶水</li><li>忌大补</li><li>辛辣生冷坚硬刺激性食物</li></ul><h2 id="产褥期卫生护理"><a href="#产褥期卫生护理" class="headerlink" title="产褥期卫生护理"></a>产褥期卫生护理</h2><p>产褥期：除了乳腺外身体各个系统恢复到未孕状态的过程（坐月子） 6-8周</p><ul><li><p>洗澡： 顺产身体允许的情况下，产后<strong>三天</strong>就可以洗澡，破宫产需要等腹部伤口恢复以后洗澡，在产后<strong>7-10天</strong> 洗澡。需要注意冬防寒，夏防署，春秋防风</p></li><li><p>月子不碰冷水，容易导致酸痛</p></li><li><p>受激素影响，月子会有牙龈出血肿胀，刷牙注意下正常现象</p></li><li><p>产褥期需要适当下床活动，否则</p><ul><li>引起肠道蠕动变慢，导致便秘</li><li>引起恶露排出不畅，导致恶露不止引起子宫复旧不良</li></ul></li><li><p>适当保持卧室通风</p></li></ul><h2 id="如何正确喂奶"><a href="#如何正确喂奶" class="headerlink" title="如何正确喂奶"></a>如何正确喂奶</h2><p>需要注意防止宝宝鼻部压着</p><p><img src="../Wife And Baby Care/image-20230319175006033.png" alt="image-20230319175006033"></p><ol><li>坐式哺乳，手臂关节处拖住宝宝头部，使他的腹部紧贴妈妈身体</li><li>侧卧式哺乳 妈妈侧卧在床，宝宝脸朝妈妈，注意不要将宝宝头枕在臂膀，宝宝的嘴和乳头 保持水平，枕头支持后背。 适合破f宫产正常产后第一天</li><li>环抱式 宝宝夹在腋下，手拖住宝宝头 </li><li>交叉</li></ol><h2 id="产妇乳房护理"><a href="#产妇乳房护理" class="headerlink" title="产妇乳房护理"></a>产妇乳房护理</h2><ol><li>母乳不足。通过婴儿吸允乳头产生刺激促进脑垂体产生分泌乳汁激素。吸的越多，产的越多；吸的越早，产的越早</li></ol><ul><li><p>早吸允（产后半小时开始） 勤吸允、按需吸允（妈妈和宝宝休要的时候）</p></li><li><p>可以喝一些崔乳汤，但是别喝太多 ，防止乳房肿胀</p></li><li><p>检测，宝宝吞咽声音，宝宝大便金黄色，2-4次&#x2F;24小时，金黄色糊状</p></li><li><p>小便6词&#x2F;24小时</p></li><li><p>宝宝体重18-30g，每月600-1000g</p></li><li><p>每次喂奶15-20分钟 7-8次每天</p></li></ul><ol start="2"><li>乳房肿胀，充血，疼痛 多出于产后2-4天</li></ol><ul><li>没有早吸允</li><li>喂奶姿势不对</li><li>产后第一天就开始大量喝浓汤</li><li>注意防范 可以导致急性乳腺炎</li><li>采用热敷，红肿时候温敷甚至冷敷。按摩疏通。</li><li>如果有发烧全身酸痛，需要及时就医</li></ul><ol start="3"><li><p>乳头皲裂</p><ul><li>注意局部卫生，可将奶水涂在皲裂处</li><li>也就而已护乳霜，喂奶时候洗干净</li><li>严重暂停哺乳，需要吸奶器吸出乳汁</li><li>严重时候红霉素眼膏涂抹患处</li></ul></li></ol><h2 id="正确检查恶露情况"><a href="#正确检查恶露情况" class="headerlink" title="正确检查恶露情况"></a>正确检查恶露情况</h2><p>恶露： 产后坏死的子宫脱膜、血液等形成的经过阴道的排出物</p><p>特征：有些血腥味，不臭，总量500-1000ml，产后3周干净</p><p>阶段：</p><ul><li>第一阶段，血性恶露，产后第一周，量多，颜色鲜红，含有大量血液，小血块喝坏死的脱膜组织 3-7天</li><li>第二阶段 浆液恶露 一周到半月内，色淡红，含有少量血液，较多的坏死脱膜，宫颈粘液，阴道分泌物</li><li>第三阶段，白色恶露 半月到3周 ，色较白，粘稠，含大量白细胞，坏死的脱膜，表皮细胞</li></ul><p>不要吃活血的东西，甜酒红糖等</p><p>异常：观察颜色量等，下腹疼痛，腰酸。产后六周后需要检查子宫恢复正常大小没</p><p><strong>产后2周后，恶露还是血性量多，伴随有恶臭味道，有时候还排除烂肉样物，或者胎膜样物，子宫复旧很差，应该考虑子宫可能残留有胎盘或者胎膜，随时可能会出现大出血现象</strong></p><h2 id="产后腰酸被背痛"><a href="#产后腰酸被背痛" class="headerlink" title="产后腰酸被背痛"></a>产后腰酸被背痛</h2><p>原因：</p><pre><code class="hljs">1.  产后长时间呆床上，活动过少 2.  腰肌劳酸 3.  产后腰部受寒</code></pre><p>生理性变化 ，一般会恢复</p><h2 id="产后问题"><a href="#产后问题" class="headerlink" title="产后问题"></a>产后问题</h2><ol><li>产褥汗</li></ol><p><img src="../Wife And Baby Care/image-20230319183032590.png" alt="image-20230319183032590"></p><p>产后身体的自我调节</p><ol start="2"><li>尿失禁</li><li>产后抑郁 一般一周后消失</li></ol><h2 id="新生儿生理"><a href="#新生儿生理" class="headerlink" title="新生儿生理"></a>新生儿生理</h2><p>新生儿： 出生到28天</p><ul><li><p>呼吸：浅且快 40-60次每分钟</p></li><li><p>心跳 120到140次每分钟 ，血液集中区块，四肢易冷出现紫绀</p></li><li><p>消化系统：容易溢奶，不适合过量。出生后24小时排除胎便，墨绿色粘稠状。没排出则需要检查是否有肛门闭锁的情况</p></li><li><p>12小时排尿。最开始4-5 后面最高20次</p></li><li><p>体温不稳定，注意保暖</p></li><li><p>母乳喂养，带有抗体，不容易得传染病</p></li><li><p>神经系统未发育，所以睡眠比较多 20小时</p></li><li><p>2-3天， 皮肤、粘膜、眼白发黄</p></li><li><p>4-5天 黄疸最重</p></li><li><p>7-10 天 逐渐消退</p></li><li><p>黄疸越来越严重 需要就医</p></li><li><p>新生儿马牙（牙床白色突起物）正常，不用挑掉</p></li><li><p>3-5天乳房肿大 泌乳，2-3周后自然消退</p></li><li><p>女宝宝假月经，一周后消失</p></li><li><p>眼睛受强光 打喷嚏</p></li><li><p>溢奶 胃小，6个月内消失</p></li><li><p>胎发母体带出，2-3周脱发，9-10周后重新长出新发</p></li></ul><h2 id="新生儿护理"><a href="#新生儿护理" class="headerlink" title="新生儿护理"></a>新生儿护理</h2><ol><li><p>胎儿大便观察</p><ul><li>大便呈黄色。粪水分开，大便次数增多，说明婴儿消化不良提示母乳含糖太多。糖分发酵，使婴儿发生肠胀气</li><li>硬结块，臭味重，说明母乳蛋白质过多，限制产妇蛋白质的摄入（鸡蛋）</li><li>大便绿色，量少，次数多，母乳营养不足</li><li>水性 肠道感染</li></ul></li><li><p>24小时需要排尿 排便。否则医院是否有先天性的堵塞问题</p></li><li><p>胎儿小便</p><ul><li>小便次数多，量少 疼痛哭闹，尿道炎症</li><li>黄色、浓茶色，摇晃尿样黄色沾便盆上，泡沫发黄，黄疸型肝炎</li><li>小便乳白色浑浊 就医</li></ul></li><li><p>人工喂养</p><p>40-60度温水倒入，再去适量奶粉放入温水，摇匀。水平摇。上下摇容易出现泡沫，宝宝吃进去空气容易导致吐奶。滴几滴到手上，测温度</p><p>喂奶倾斜，平躺会导致吞咽困难和被呛</p><p>奶瓶45° </p><p>奶嘴充满奶液，以免吸入空气</p></li><li><p>新生儿 囟门与乳伽的护理</p><p>新生儿脑颅的窗户  叫囟门 </p><p>囟门时大脑开放的空隙 很容易受到外界不利因素的侵害</p><ul><li>不要太硬的枕头</li><li>孩子喜欢光线 </li><li>不慎擦破头皮  诺合典以防止感染</li><li>冬天加厚的帽子</li><li>洗澡清洗，温柔点洗，难洗的植物油</li><li>乳加 头皮皮脂腺分泌物 植物油清洗，泡2个小时 再洗。洗净后婴儿粉处理</li><li>不要用硬物</li></ul></li><li><p>哭声识别</p><ul><li>饥饿：哭声较短，长短均匀，富有节奏，头左右摆动，张开小嘴寻觅，碰到衣物吸允</li><li>拉了尿了： 哭声长短不一，高低不均匀，边哭边活动臀部，两脚乱踢乱动</li><li>需要安全感：哭声长短不一 ，高低不均匀，无节奏感</li><li>保暖过度  ：大声哭，面红耳赤，全身出汗，四肢乱蹬，提问升高</li><li>入睡前： 哭声低，双目时睁时闭</li><li>边吃边哭 ： 母乳过少或过大， 奶嘴开口过小</li><li>疾病苦恼： 尖声哭 脸色苍白</li></ul></li><li><p>新生儿睡眠</p><ul><li>新生儿平均18小时，两个小时-4个小时醒来一次</li><li>经常变换体位，更换睡眠姿势，长期仰睡，头型扁平，侧卧透心易歪偏</li><li>长期哄睡或者抱睡容易影响脊柱发育，也容易造成后续的</li><li>睡眠需要注意手放在外面，这样不容易被子盖住鼻子 导致窒息</li><li>不用太注重环境的安静，避免后面小孩出生就开始吵闹</li></ul></li></ol><p>参考连接：</p><table><thead><tr><th>内容描述</th><th>地址</th></tr></thead><tbody><tr><td>照顾宝宝</td><td><a href="https://www.bilibili.com/video/BV1Rb411T7no/?spm_id_from=autoNext&vd_source=4e5aa97e1b33879fb670ca96605ff476">https://www.bilibili.com/video/BV1Rb411T7no/?spm_id_from=autoNext&amp;vd_source=4e5aa97e1b33879fb670ca96605ff476</a></td></tr><tr><td>抱宝宝</td><td><a href="https://www.bilibili.com/video/BV1NY4y1t7tg/?spm_id_from=333.788.recommend_more_video.3&vd_source=4e5aa97e1b33879fb670ca96605ff476">https://www.bilibili.com/video/BV1NY4y1t7tg/?spm_id_from=333.788.recommend_more_video.3&amp;vd_source=4e5aa97e1b33879fb670ca96605ff476</a></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决hexo 博客图片路径问题</title>
    <link href="/2023/03/17/%E8%A7%A3%E5%86%B3hexo-%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/17/%E8%A7%A3%E5%86%B3hexo-%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="解决hexo-博客图片路径问题"><a href="#解决hexo-博客图片路径问题" class="headerlink" title="解决hexo 博客图片路径问题"></a>解决hexo 博客图片路径问题</h1><p>  以前一直用的时在线图片，发现很多图片连接失效了，导致图片加载失败，于是想放本地。查询相关资料后，选择放本地改为相对路径引用,有2种方式</p><ol><li><p>为每一个md文件建一个同名文件夹，把图片等静态资源放文件夹里面</p></li><li><p>建设一个公共的文件夹eg: Image，把所有的md文件引入的图片都 放里面</p><p>考虑到万一哪一天迁移，或者清理图片，图片多了不方便寻找，于是选择了方案1 ，用文件夹隔离</p><p>_config.yml 文件夹 配置   <code>post_asset_folder: true</code></p><p>此时还是有问题</p></li></ol><p>  原始MD文件引入  中文目录名&#x2F;图片.jpg&#x3D;&#x3D;&gt;  中文目录名&#x2F;%E5%9B%BE%E7%89%87.jpg </p><p>   图片encode了 但是 目录名未encode</p><p>   解决办法，全部改回去：</p><p><img src="../解决hexo-博客图片路径问题/image-20230317190307757.png" alt="image-20230317190307757"></p><p>​  </p><p>​</p><p>新建一个js文件 ，放在script下面 ，内容如下 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">filter</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> arr =  data.<span class="hljs-property">content</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(&lt;img.* src=?\&quot;)(.*)\&quot; alt.*&gt;/ig</span>)<br> <span class="hljs-keyword">if</span>(arr) &#123;<br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">let</span> replaceItem = <span class="hljs-built_in">decodeURIComponent</span>(item)<br>      replaceItem =replaceItem.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;src=&quot;/&#x27;</span>,<span class="hljs-string">&#x27;src=&quot;../&#x27;</span>)<br>      data.<span class="hljs-property">content</span> = data.<span class="hljs-property">content</span>.<span class="hljs-title function_">replace</span>(item,replaceItem)<br>  &#125;)<br> &#125;<br>  <span class="hljs-keyword">return</span> data;<br>&#125;);<br></code></pre></td></tr></table></figure><p>vscode Node调试</p><p> 打开调试&#x3D;&#x3D;&gt; 打开配置&#x3D;&#x3D;&gt; 添加终端调试&#x3D;&#x3D; 命令 “hexo g”  即可开启node调试</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>图片连接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java之反射</title>
    <link href="/2023/03/13/java%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
    <url>/2023/03/13/java%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="java之反射"><a href="#java之反射" class="headerlink" title="java之反射"></a>java之反射</h1><p>一直不理解反射是啥，闲暇时间找了翻了下《Java 核心技术》 略微理解了点</p><p>习惯了<code>javascript</code>，再去理解java的反射特性十分别扭，<code>Javascript </code>是个脚本语音，<strong>动态语言</strong>， 而javas是<strong>静态语言</strong>，得编译成字节码，虚拟机解析执行，运行时不像JS能够直接通过<code>Object.property </code>或者<code>Object.method</code>在运行时去修改对象属性、方法等。</p><p>但是 ，很多时候为了写出通用性代码，增强某些类、某些方法，特别是第三方框架，这种时候就需要去动态操作<code>java</code>代码</p><p>整理网上一些资料重点信息</p><h2 id="反射是什么"><a href="#反射是什么" class="headerlink" title="反射是什么"></a>反射是什么</h2><p><strong>能够分析类能力的程序称为反射</strong></p><p>反射库（reflection library）提供了一个丰富且精巧的工具集，可以用来编写和操纵<code>Java</code>代码</p><p>作用：</p><ul><li><p>在运行时分析类的能力</p></li><li><p>在运行时检查对象被</p></li><li><p>实现泛型数组操作代码</p></li><li><p>利用Method对象，调用类的方法</p></li></ul><p><strong>核心围绕<code>Class</code>对象 以及 <code>java.lang.reflect</code>类库  API学习</strong></p><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>在程序运行期间，<code>Java</code>运行时系统始终为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属于类，虚拟机利用运行时类型信息选择要执行的正确方法。</p><p>如何获取class对象</p><p>1.每个 类都有class属性, 返回就是这个类的Class对象    </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Employee e;<br><span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Employee.class<br></code></pre></td></tr></table></figure><p>2.每个对象都有getClass()方法, 返回这个类运行时类对象, 即该类的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Employee e;<br><span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> e.getClass<br></code></pre></td></tr></table></figure><p>3.Class.forName(类的全限定名) , 返回类Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(com.test.Employee)<br></code></pre></td></tr></table></figure><blockquote><p>在启动时 包含main方法的类被加载，它会加载所有需要的类。这些类又要加载其它依赖的类，这样会花费很长时间。所以可以在运行时去调用Class.forName手工加载其他类</p></blockquote><p>如何通过反射创建对象,主要有两种方式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">class</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;reflection.Student&quot;</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) class.newInstance();<br>System.out.println(student);<br><br><span class="hljs-comment">//方式二</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">class</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;reflection.Student&quot;</span>);<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> class.getConstructor();<br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) constructor.newInstance();<br>System.out.println(student);<br><br><br><br></code></pre></td></tr></table></figure><p>​</p><p>从网上找的图片参考处 </p><p>![(java之反射&#x2F;28b74b5a79064daaa21f2a6ed96d417c-1678973390687.png)</p><p><img src="../java之反射/28b74b5a79064daaa21f2a6ed96d417c-1678973390687.png" alt=""></p><p>Java虚拟机创建的，所以不需要显示申明 ，手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</p><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="../java之反射/image-20230314210305216.png![image-20230330165219770](java之反射/image-20230330165219770.png" alt="image-20230314210305216"></p><p>加载：类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象</p><p>链接：验证字节码的安全性和完整性，准备阶段正式为静态域分配存储空间，注意此时只是分配静态成员变量的存储空间，不包含实例成员变量，如果必要的话，解析这个类创建的对其他类的所有引用。</p><p>初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量</p><p>双亲委派机制</p><p><img src="../java之反射/5p6jdXDA8VtCEfN.png" alt="img"></p><p>实际上类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader加载的，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载</p><h2 id="判断类继承关系API"><a href="#判断类继承关系API" class="headerlink" title="判断类继承关系API"></a>判断类继承关系API</h2><ol><li><p>str instanceof String</p></li><li><p>str.getClass() &#x3D;&#x3D; String.class</p></li><li><p>i.getClass().asSubclass(Number.class)   &#x2F;&#x2F;  如果需要判断是否为子类或是接口&#x2F;抽象类的实现，我们可以使用<code>asSubClass()</code>方法</p></li><li><p>i.getClass().getSuperclass() <code>getSuperclass()</code>方法，我们可以获取到父类的Class对象</p></li></ol><p>反射创建对象  返回泛型T，当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为<code>newInstance()</code>只适用于默认无参构造</p><p> Class<Student> clazz &#x3D; Student.class;    Student student &#x3D; clazz.newInstance();  </p><ol start="5"><li><p>反射的时候优先去获取构造器去创建对象 ，newInstance（）只适合无参</p><p>  Class<Student> clazz &#x3D; Student.class;    Student student &#x3D; clazz.getConstructor(String.class).newInstance(“what’s up”);</p></li><li><p>Class<Student> clazz &#x3D; Student.class; Constructor<Student> constructor &#x3D; clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true);   <em>&#x2F;&#x2F;修改访问权限</em></p><p>意味着，反射可以无视权限修饰符访问类的内容</p></li><li><p>反射非常强大，越权访问</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typero quik start</title>
    <link href="/2023/03/13/typero&amp;markdown%20%20quick%20start/"/>
    <url>/2023/03/13/typero&amp;markdown%20%20quick%20start/</url>
    
    <content type="html"><![CDATA[<h1 id="typero-markdown-quick-start"><a href="#typero-markdown-quick-start" class="headerlink" title="typero&amp;markdown  quick start"></a>typero&amp;markdown  quick start</h1><p>整理个人常用markdown语法以及typero编辑器的快捷键</p><p>​</p><h2 id="实用快捷键"><a href="#实用快捷键" class="headerlink" title="实用快捷键"></a>实用快捷键</h2><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>创建表格</td><td>Ctrl+T</td></tr><tr><td>加粗</td><td>Ctrl+B</td></tr><tr><td>加斜杠</td><td>Ctrl+I</td></tr><tr><td>插入公式</td><td>Ctrl + shift + M</td></tr><tr><td>粘贴为纯文本</td><td>Ctrl + shift + V</td></tr><tr><td>跳转到文首</td><td>Ctrl + End</td></tr><tr><td>跳转到文末</td><td>Ctrl + Home</td></tr><tr><td>源码模式</td><td>Ctrl + &#x2F;</td></tr></tbody></table><h2 id="常用markdown-语法"><a href="#常用markdown-语法" class="headerlink" title="常用markdown 语法"></a>常用markdown 语法</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tex">1.[文本](连接)<br>2.**Typora**    加粗强调<br>3.`Copy as Markdown`   <br>4.`&lt;h1&gt;HEADING&lt;/h1&gt;`<br>5.- 实心的无序列表<br>6.*斜体*<br>7.*** 斜体加粗***<br>8.~~删除文本~~<br>9.分割线三个或者三个以上的 - 或者 * 都可以 *****。、<br>10.无序列表或者有序列表上一级和下一级之间敲三个空格即可<br>11. `单行代码`<br>12.流程图<br>​```flow<br>st=&gt;start: 开始<br>op=&gt;operation: My Operation<br>cond=&gt;condition: Yes or No?<br>e=&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br><span class="hljs-built_in">&amp;</span>```<br><br></code></pre></td></tr></table></figure><hr><p><strong>以下是预览效果</strong></p><p>1.<a href="%E8%BF%9E%E6%8E%A5">文本</a><br>2.<strong>Typora</strong>    加粗强调</p><p>3.<code>Copy as Markdown</code>   <code>单行代码</code><br>4.<code>&lt;h1&gt;HEADING&lt;/h1&gt;</code><br>5.- 实心的无序列表<br>6.<em>斜体</em><br>7.*** 斜体加粗***<br>8.<del>删除文本</del></p><p>9.流程图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 开始<br>op=&gt;operation: My Operation<br>cond=&gt;condition: Yes or No?<br>e=&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;opd<br>&amp;```<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 是什么？</title>
    <link href="/2023/03/09/docker%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2023/03/09/docker%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-是什么？"><a href="#docker-是什么？" class="headerlink" title="docker 是什么？"></a>docker 是什么？</h1><blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux内核的机器上，也可以实现虚拟化。Docker 镜像可以推送到存储库，也可以下拉到任何其他主机以从该镜像运行容器。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p> 切换环境的时候，由于环境变化导致部署出问题。为了避免这种情况就诞生了容器技术，相比虚拟机，更加节约资源，虚拟机是把硬件资源分割，操作系统隔离。</p></blockquote><h2 id="前提容器是什么"><a href="#前提容器是什么" class="headerlink" title="前提容器是什么"></a>前提容器是什么</h2><p><strong>用户空间（user space）：</strong>运行用户程序（应用程序、进程）所需的所有代码被称为用户空间。当启动程序操作时，例如创建一个文件，用户空间中的进程会向内核空间发出系统调用。</p><p><strong>内核空间（kernel space）：</strong>这里有着与系统硬件、存储等交互的内核代码，是操作系统的核心。</p><p>容器基本上是一个具有足够隔离用户空间组件的进程，因此它给人一种独立操作系统的感觉。Linux 有两个重要的内核功能，分别是<strong>命名空间（namespaces）</strong>和<strong>控制组（control groups）</strong>。在主机中，容器与容器之间的隔离正是由这两个内核功能实现的。</p><h2 id="docker对比虚拟机"><a href="#docker对比虚拟机" class="headerlink" title="docker对比虚拟机"></a>docker对比虚拟机</h2><p><strong>资源利用和成本</strong></p><ul><li>我们可以使用虚拟机独立运行应用程序，这里所谓的独立运行是指一台虚拟器运行一个服务。但是虚拟机仍然可能未被充分利用。此外，为应用程序调整虚拟机的大小并不是一件容易的事。</li><li>另一方面，容器可以在非常小的 CPU 和内存上运行。此外，您甚至可以在 VM 内运行多个容器以进行应用程序隔离。另外，调整容器大小需要几秒钟。</li></ul><p><strong>配置和部署</strong></p><ul><li>取决于所涉及的工作流，配置虚拟机并在其上部署应用程序可能需要几分钟到几小时的时间，即使回滚也需要时间。</li><li>但是我们却可以在几秒钟内部署一个容器，并在几秒钟内将其回滚。</li></ul><p><strong>漂移管理</strong></p><ul><li><p>虚拟机中的漂移管理并不容易。我们需要拥有成熟的自动化和流程，以确保所有环境都相似。遵循不可变的部署模型可避免虚拟机环境中的漂移。</p></li><li><p>对于容器，一旦镜像生成，那么它在所有环境中都是一样的。要进行任何更改时，我们需要开始在 dev env 中进行更改并重新生成容器映像。</p><p>​</p></li></ul><p></p><h2 id="docker-容器和Linux容器区别（LXC）"><a href="#docker-容器和Linux容器区别（LXC）" class="headerlink" title="docker 容器和Linux容器区别（LXC）"></a>docker 容器和Linux容器区别（LXC）</h2><p>Docker 最初是构建在 Linux 容器 (LXC) 之上的，但后来 Docker 用自己的容器运行时 libcontainer（现在是runc 的一部分）替换了 LXC。</p><p>启动 docker 容器非常快速，只需不到一秒钟，而且 Docker 可以在任何具有兼容 Linux 内核的主机上运行。（也支持 Windows）</p><ul><li><p>注意：我们不能在 Linux 主机上运行 Windows 容器，因为 Windows 没有 Linux 内核支持。</p><p><img src="../docker是什么/v2-d3e8d994586ec0d409c0fcbf1f580174_720w.webp" alt="img"></p><h2 id="docker-是如何工作的"><a href="#docker-是如何工作的" class="headerlink" title="docker 是如何工作的"></a>docker 是如何工作的</h2><p><strong>docker工作流程</strong></p><p><img src="../docker是什么/v2-32252d25fca277a9b0e084c9b84f9752_720w.webp" alt="img"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整合mybatius</title>
    <link href="/2023/02/20/%E6%95%B4%E5%90%88mybatius/"/>
    <url>/2023/02/20/%E6%95%B4%E5%90%88mybatius/</url>
    
    <content type="html"><![CDATA[<h2 id="整合Mybatius"><a href="#整合Mybatius" class="headerlink" title="整合Mybatius"></a>整合Mybatius</h2><p>1.依赖项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.配置连接驱动 数据库 以及账户密码</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/infytime</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>3.测试demo</p><p>Dao层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.godbutton.imp;<br><br><span class="hljs-keyword">import</span> com.godbutton.entity.Book;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from book where id=#&#123;id&#125;&quot;)</span><br>   <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">findBook</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Entity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.godbutton.entity;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String author;<br>    <span class="hljs-keyword">private</span> String publish;<br>    <span class="hljs-keyword">private</span> Integer page;<br>    <span class="hljs-keyword">private</span> Float price;<br>    <span class="hljs-keyword">private</span> Integer bookCaseId;<br>    <span class="hljs-keyword">private</span> Integer abled;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id +<span class="hljs-string">&quot;:&quot;</span> +name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAuthor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> author;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAuthor</span><span class="hljs-params">(String author)</span> &#123;<br>        <span class="hljs-built_in">this</span>.author = author;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPublish</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> publish;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPublish</span><span class="hljs-params">(String publish)</span> &#123;<br>        <span class="hljs-built_in">this</span>.publish = publish;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getPage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> page;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPage</span><span class="hljs-params">(Integer page)</span> &#123;<br>        <span class="hljs-built_in">this</span>.page = page;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Float <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrice</span><span class="hljs-params">(Float price)</span> &#123;<br>        <span class="hljs-built_in">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBookCaseId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> bookCaseId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBookCaseId</span><span class="hljs-params">(Integer bookCaseId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookCaseId = bookCaseId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAbled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> abled;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAbled</span><span class="hljs-params">(Integer abled)</span> &#123;<br>        <span class="hljs-built_in">this</span>.abled = abled;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Control+Server</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.godbutton.controller;<br><span class="hljs-keyword">import</span> com.godbutton.imp.BookDao;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/book/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span>  BookDao bookDao;<br><span class="hljs-meta">@RequestMapping()</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBook</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id )</span> &#123;<br>      <span class="hljs-keyword">return</span> bookDao.findBook(id);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>mybatius</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring-boot</title>
    <link href="/2023/02/19/spring-boot/"/>
    <url>/2023/02/19/spring-boot/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-boot-快速开始"><a href="#Spring-boot-快速开始" class="headerlink" title="Spring-boot 快速开始"></a>Spring-boot 快速开始</h2><p>一.设置maven配置</p><p>​1.配置镜像仓库 阿里云</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>初始化项目 解决链接不上的 问题</p><p><code>https://start.spring.io  ==&gt;  https://start.aliyun.com</code></p></li><li><p>常见注解</p><table><thead><tr><th>注解</th><th>作用</th><th></th></tr></thead><tbody><tr><td>@RestControl</td><td></td><td>等同于@Controller + @ResponseBody</td></tr><tr><td>@ResponseBody</td><td>表示方法的返回值直接以指定的格式写入Http response body中，而不是解析为跳转路径。</td><td></td></tr><tr><td>@EnableAutoConfiguration</td><td>即把指定的类构造成对象，并放入spring容器中，使其成为bean对象</td><td>springboot启动的时候，会扫描该项目下所有spring.factories文件，底层也是springfactoriesLoader</td></tr><tr><td>@SpringBootConfiguration</td><td></td><td></td></tr><tr><td>@ComponentScan</td><td></td><td></td></tr><tr><td>@SpringBootApplication</td><td>包含了EnableAutoConfiguration 、SpringBootConfiguration、ComponentScan</td><td></td></tr><tr><td>@ConfigurationProperties</td><td>获取配置参数</td><td></td></tr><tr><td>@Configuration</td><td>标识它是一个配置类</td><td>通常配合工厂函数使用</td></tr></tbody></table></li><li><p>特性 </p><p>1.内嵌Tomcat、Jetty或者Undertow</p><p>2.简化配置 简化部署 简化编码 简化配置</p></li><li><pre><code class="xml">核心配置    &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre></li></ol><h2 id="spring-boot-装配参考，"><a href="#spring-boot-装配参考，" class="headerlink" title="spring  boot 装配参考，"></a>spring  boot 装配参考，</h2><ol><li><p>自动装配:  <a href="https://blog.csdn.net/xueyijin/article/details/124853073">https://blog.csdn.net/xueyijin/article/details/124853073</a></p></li><li><p>如何打包成1个包给别人项目依赖： <a href="https://blog.csdn.net/xueyijin/article/details/124852621">https://blog.csdn.net/xueyijin/article/details/124852621</a></p></li></ol><p>​      分几种场景</p><ul><li>springboot默认扫描路径，启动类所在的包， 带有<code>@Component</code>或者<code>@Configuration</code>注解的类</li><li>引入第三方jar包(里面也有bean对象)   根据sdk里面 spring.factories</li><li>如果第三方包需要传参 @EnableConfigurationProperties</li></ul><p>如下 自己封装了个GetMax类 里面有2个方法，一个无参 一个有参数  但是还是常规的 包引用方式 </p><p><img src="../spring-boot/image-20230322161516026.png" alt="image-20230322161516026"></p><p>如何转化成Bean对象？</p><ol><li><p>componentScan  需要第三方包里面写了@component注解</p></li><li><p>在SDK中的spring.factories加入该配置类的权限类路径，实际也很少，查看的时候实际绝大部分都是工厂函数</p></li><li><p>使用工厂函数注入  ，调用的A类的构造函数 ，返回注入的是B类的实例 ，AutoWird 注入B</p><p><img src="../spring-boot/image-20230322175502002.png" alt="image-20230322175502002"></p><p><img src="../spring-boot/image-20230322175518378.png" alt="image-20230322175518378"></p></li></ol><p>普通YML配置   注入</p><p><img src="../spring-boot/image-20230322181117679.png" alt="image-20230322181117679"></p>]]></content>
    
    
    
    <tags>
      
      <tag>spring-boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
